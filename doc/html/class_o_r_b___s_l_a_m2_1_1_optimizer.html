<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Os1: ORB_SLAM2::Optimizer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Os1
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">OrbSlam2 documentado y modificado</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,'Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_o_r_b___s_l_a_m2_1_1_optimizer.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_o_r_b___s_l_a_m2_1_1_optimizer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ORB_SLAM2::Optimizer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html" title="Optimizer concentra todas las operaciones con g2o. ">Optimizer</a> concentra todas las operaciones con <a class="el" href="namespaceg2o.html">g2o</a>.  
 <a href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_optimizer_8h_source.html">Optimizer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aac6bf926792ed8a013d64897879a89ec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#aac6bf926792ed8a013d64897879a89ec">BundleAdjustment</a> (const std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&gt; &amp;vpKF, const std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;vpMP, int nIterations=5, bool *pbStopFlag=NULL, const unsigned long nLoopKF=0, const bool bRobust=true)</td></tr>
<tr class="memdesc:aac6bf926792ed8a013d64897879a89ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundle adjusment sobre los keyframes y puntos el mapa pasados como argumentos.  <a href="#aac6bf926792ed8a013d64897879a89ec">More...</a><br /></td></tr>
<tr class="separator:aac6bf926792ed8a013d64897879a89ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9b8a4c16296bf2981b0aaf4ee3189c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#aaa9b8a4c16296bf2981b0aaf4ee3189c">GlobalBundleAdjustemnt</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html">Map</a> *pMap, int nIterations=5, bool *pbStopFlag=NULL, const unsigned long nLoopKF=0, const bool bRobust=true)</td></tr>
<tr class="memdesc:aaa9b8a4c16296bf2981b0aaf4ee3189c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ejecuta BundleAdjustment sobre todo el mapa.  <a href="#aaa9b8a4c16296bf2981b0aaf4ee3189c">More...</a><br /></td></tr>
<tr class="separator:aaa9b8a4c16296bf2981b0aaf4ee3189c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70e0b4f366b65a0c1ae8b2def19d339"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#ab70e0b4f366b65a0c1ae8b2def19d339">LocalBundleAdjustment</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF, bool *pbStopFlag, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html">Map</a> *pMap)</td></tr>
<tr class="memdesc:ab70e0b4f366b65a0c1ae8b2def19d339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundle adjusment local a partir de un keyframe.  <a href="#ab70e0b4f366b65a0c1ae8b2def19d339">More...</a><br /></td></tr>
<tr class="separator:ab70e0b4f366b65a0c1ae8b2def19d339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a53ab409feed7f92547eb79a2d7f6e9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#a5a53ab409feed7f92547eb79a2d7f6e9">OptimizeEssentialGraph</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html">Map</a> *pMap, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pLoopKF, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pCurKF, const <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#ae9ada143a8308ce32990a7c7b5d533ab">LoopClosing::KeyFrameAndPose</a> &amp;NonCorrectedSim3, const <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#ae9ada143a8308ce32990a7c7b5d533ab">LoopClosing::KeyFrameAndPose</a> &amp;CorrectedSim3, const map&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *, set&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&gt; &gt; &amp;LoopConnections, const bool &amp;bFixScale)</td></tr>
<tr class="memdesc:a5a53ab409feed7f92547eb79a2d7f6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimiza el grafo esencial para cerrar un bucle.  <a href="#a5a53ab409feed7f92547eb79a2d7f6e9">More...</a><br /></td></tr>
<tr class="separator:a5a53ab409feed7f92547eb79a2d7f6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5158a64390b806687666c1e93425120d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#a5158a64390b806687666c1e93425120d">OptimizeSim3</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF1, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF2, std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;vpMatches1, <a class="el" href="structg2o_1_1_sim3.html">g2o::Sim3</a> &amp;g2oS12, const float th2)</td></tr>
<tr class="memdesc:a5158a64390b806687666c1e93425120d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depura la transformación sim3 (espacio de transformaciones de similaridad, de 7 dimensiones) entre dos keyframes, que mejor explica un macheo.  <a href="#a5158a64390b806687666c1e93425120d">More...</a><br /></td></tr>
<tr class="separator:a5158a64390b806687666c1e93425120d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7415d78b8a2323b88e108fa1ea3bf2d3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#a7415d78b8a2323b88e108fa1ea3bf2d3">PoseOptimization</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> *pFrame)</td></tr>
<tr class="memdesc:a7415d78b8a2323b88e108fa1ea3bf2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cómputo de la pose de un cuadro.  <a href="#a7415d78b8a2323b88e108fa1ea3bf2d3">More...</a><br /></td></tr>
<tr class="separator:a7415d78b8a2323b88e108fa1ea3bf2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html" title="Optimizer concentra todas las operaciones con g2o. ">Optimizer</a> concentra todas las operaciones con <a class="el" href="namespaceg2o.html">g2o</a>. </p>
<p>Esta clase no tiene propiedades, sino solamente un conjunto métodos estáticos o de clase. <a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html" title="Optimizer concentra todas las operaciones con g2o. ">Optimizer</a> no se instancia, funciona como un espacio de nombres.</p>
<p>Concentra todas las funciones implementadas con el framework <a class="el" href="namespaceg2o.html">g2o</a>, que incluyen bundle adjustment, pose optimization y graph optimization.</p>
<p>Los métodos de bundle adjustment utilizan <a class="el" href="namespaceg2o.html">g2o</a> de la misma manera, descrita en <a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#ab70e0b4f366b65a0c1ae8b2def19d339" title="Bundle adjusment local a partir de un keyframe. ">Optimizer::LocalBundleAdjustment</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aac6bf926792ed8a013d64897879a89ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::Optimizer::BundleAdjustment </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>vpKF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>vpMP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIterations</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pbStopFlag</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>nLoopKF</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>bRobust</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bundle adjusment sobre los keyframes y puntos el mapa pasados como argumentos. </p>
<p>Toma todos los keyframes y todos los puntos del mapa, para ejecutar un BA. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vpKFs</td><td>Vector de keyframes. Cada keyframe contiene los puntos 2d visualizados, y su relación con los puntos del mapa. </td></tr>
    <tr><td class="paramname">vpMP</td><td>Vector de puntos del mapa. </td></tr>
    <tr><td class="paramname">nIterations</td><td>Cantidad de iteraciones máximas para el BA. </td></tr>
    <tr><td class="paramname">pbStopFlag</td><td>Señal para forzar la parada del optimizador. </td></tr>
    <tr><td class="paramname">nLoopKF</td><td></td></tr>
    <tr><td class="paramname">bRobust</td><td>Señal que solicita un evaluador robusto (que admite outliers) en lugar de uno estricto (que asume que todos los puntos son válidos).</td></tr>
  </table>
  </dd>
</dl>
<p>Este método se invoca solamente desde Optimizer::GlobalBundleAdjustment.</p>
<h3>Funcionamiento</h3>
<p>El optimizador se arma así, exactamente igual que <a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#ab70e0b4f366b65a0c1ae8b2def19d339" title="Bundle adjusment local a partir de un keyframe. ">Optimizer::LocalBundleAdjustment</a>: </p><pre class="fragment">typedef BlockSolver&lt; BlockSolverTraits&lt;6, 3&gt; &gt; BlockSolver_6_3;
g2o::SparseOptimizer optimizer;
optimizer.setAlgorithm(
    new g2o::OptimizationAlgorithmLevenberg(
        new g2o::BlockSolver_6_3(
            new g2o::LinearSolverEigen&lt;g2o::BlockSolver_6_3::PoseMatrixType&gt;()
        )
    )
);
</pre><p>BlockSolver_6_3::PoseMatrixType es MatrixXD ?, es decir de elementos double y dimensiones por definir. Este código significa: optimizador espaciado, con algoritmo LM, solucionador de bloque para poses de 6 dimensiones y puntos de 3 dimensiones, usando Cholesky espaciado de la librería Eigen.</p>
<p>Vértices:</p><ul>
<li><a class="el" href="classg2o_1_1_vertex_s_e3_expmap.html" title="SE3 Vertex parameterized internally with a transformation matrix and externally with its exponential ...">g2o::VertexSE3Expmap</a>: pose de keyframe</li>
<li><a class="el" href="classg2o_1_1_vertex_s_b_a_point_x_y_z.html" title="Point vertex, XYZ. ">g2o::VertexSBAPointXYZ</a>: posición del mappoint</li>
</ul>
<p>Ejes:</p><ul>
<li><a class="el" href="classg2o_1_1_edge_s_e3_project_x_y_z.html">g2o::EdgeSE3ProjectXYZ</a><ul>
<li>vértice 0: mappoint</li>
<li>vértice 1: keyframe</li>
<li>medición: coordenadas del keypoint</li>
<li>información: invSigma2 de la octava del keypoint </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="aaa9b8a4c16296bf2981b0aaf4ee3189c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::Optimizer::GlobalBundleAdjustemnt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html">Map</a> *&#160;</td>
          <td class="paramname"><em>pMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nIterations</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pbStopFlag</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned long&#160;</td>
          <td class="paramname"><em>nLoopKF</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>bRobust</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ejecuta BundleAdjustment sobre todo el mapa. </p>
<p>Toma todos los keyframes y todos los puntos del mapa, para ejecutar un BA. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMap</td><td>Mapa, de donde tomar todos los keyframes y los puntos. </td></tr>
    <tr><td class="paramname">nIterations</td><td>Cantidad de iteraciones máximas para el BA, pasado tal cual a BundleAdjustment. </td></tr>
    <tr><td class="paramname">pbStopFlag</td><td>Señal para forzar la parada del optimizador, pasado tal cual a BundleAdjustment. </td></tr>
    <tr><td class="paramname">nLoopKF</td><td></td></tr>
    <tr><td class="paramname">bRobust</td><td>Señal que solicita un evaluador robusto (que admite outliers) en lugar de uno estricto (que asume que todos los puntos son válidos).</td></tr>
  </table>
  </dd>
</dl>
<p>Este método se invoca solamente desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html#afeb077c81cd700d779348b80698086e8" title="Crea el mapa inicial. ">Tracking::CreateInitialMapMonocular</a> al inicio del tracking, cuando el mapa es pequeno, y desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#a4b10a9c18541818c9490a62447ef7f18" title="Bundle adjustment sobre todo el mapa luego de cerrar el bucle. ">LoopClosing::RunGlobalBundleAdjustment</a> para corregir el mapa luego de cerrar un bucle. </p>

</div>
</div>
<a id="ab70e0b4f366b65a0c1ae8b2def19d339"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::Optimizer::LocalBundleAdjustment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pbStopFlag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html">Map</a> *&#160;</td>
          <td class="paramname"><em>pMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bundle adjusment local a partir de un keyframe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF</td><td>Keyframe inicial, usualmente Tracking::mpCurrentKeyFrame. </td></tr>
    <tr><td class="paramname">pbStopFlag</td><td>Señal para forzar la parada del optimizador. </td></tr>
    <tr><td class="paramname">pMap</td><td>Mapa del mundo.</td></tr>
  </table>
  </dd>
</dl>
<p>El BA local toma el keyframe de referencia (usualmente el actual). A partir de él forma un vector de keyframes covisibles con <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a9315d396634f6637f70f716336777b8d" title="Devuelve el vector de keyframes covisibles KeyFrame::mvpOrderedConnectedKeyFrames ...">KeyFrame::GetVectorCovisibleKeyFrames()</a>, y un vector de puntos del mapa vistos por ellos. Estos keyframes y puntos del mapa serán modificados por el BA. Finalmente crea un vector de keyframes fijos (no afectados por el BA), con los otros keyframes que también observan esos puntos. Con estos datos ejecuta un BA usando <a class="el" href="namespaceg2o.html">g2o</a>.</p>
<p>Éste es el Bundle adjustment periódico del tracking.</p>
<p>Este método se invoca solamente desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_local_mapping.html#a0f9fa8a0236f55629b0f485db05deb2c" title="Bucle principal del thread de mapeo local. ">LocalMapping::Run()</a>.</p>
<p>El optimizador se arma así: </p><pre class="fragment">g2o::SparseOptimizer optimizer;
optimizer.setAlgorithm(
    new g2o::OptimizationAlgorithmLevenberg(
        new g2o::BlockSolver_6_3(
            new g2o::LinearSolverEigen&lt;g2o::BlockSolver_6_3::PoseMatrixType&gt;()
        )
    )
);
</pre><p>BlockSolver_6_3::PoseMatrixType es MatrixXD ?, es decir de elementos double y dimensiones por definir. Este código significa: optimizador espaciado, con algoritmo LM, solucionador de bloque de ejes que unen poses de 6 dimensiones y puntos de 3 dimensiones, usando Cholesky espaciado de la librería Eigen.</p>
<p>Las poses de los keyframes y las posiciones de los puntos 3D constituyen los vértices: </p><pre class="fragment">g2o::VertexSE3Expmap * vSE3 = new g2o::VertexSE3Expmap();
vSE3-&gt;setEstimate(Converter::toSE3Quat(pKF-&gt;GetPose()));
vSE3-&gt;setId(id del vertex);
vSE3-&gt;setFixed(true o false);
optimizer.addVertex(vSE3);

g2o::VertexSBAPointXYZ* vPoint = new g2o::VertexSBAPointXYZ();
vPoint-&gt;setEstimate(Converter::toVector3d(pMP-&gt;GetWorldPos()));
vPoint-&gt;setId(id del vertex);
vPoint-&gt;setMarginalized(true);
optimizer.addVertex(vPoint);
</pre><p>Las poses de los keyframes se expresan como <a class="el" href="classg2o_1_1_vertex_s_e3_expmap.html" title="SE3 Vertex parameterized internally with a transformation matrix and externally with its exponential ...">g2o::VertexSE3Expmap</a>, mapas exponenciales del grupo de simetría del espacio euclideano de 3 dimensiones (que tiene 6 grados de libertad). Se fijan las poses de los keyframes que observan a los puntos locales, sin pertenecer al grafo de covisibilidad.</p>
<p>Las poses d elos puntos se expresan como <a class="el" href="classg2o_1_1_vertex_s_b_a_point_x_y_z.html" title="Point vertex, XYZ. ">g2o::VertexSBAPointXYZ</a>, puntos xyz para BA espaciado.</p>
<p>Los ejes que proyectan uno al otro son <a class="el" href="classg2o_1_1_edge_s_e3_project_x_y_z.html">g2o::EdgeSE3ProjectXYZ</a>;</p>
<p>Los ejes unen keyframes con puntos, un eje para cada observación de cada punto: </p><pre class="fragment">g2o::EdgeSE3ProjectXYZ* e = new g2o::EdgeSE3ProjectXYZ();
 e-&gt;setVertex(0, dynamic_cast&lt;g2o::OptimizableGraph::Vertex*&gt;(optimizer.vertex(id del vertex KeyFrame)));
 e-&gt;setVertex(1, dynamic_cast&lt;g2o::OptimizableGraph::Vertex*&gt;(optimizer.vertex(id del vertex MapPoint)));
 e-&gt;setMeasurement(coordenadas del punto singular);
 e-&gt;setInformation(Eigen::Matrix2d::Identity()*invSigma2);  // invSigma2 correspondiente a la observación de ese punto en ese keyframe
 e-&gt;setRobustKernel(new g2o::RobustKernelHuber);
 rk-&gt;setDelta(sqrt(5.991));

 e-&gt;fx = pKFi-&gt;fx;
 e-&gt;fy = pKFi-&gt;fy;
 e-&gt;cx = pKFi-&gt;cx;
 e-&gt;cy = pKFi-&gt;cy;

 optimizer.addEdge(e);
</pre><p>La matriz de información es la identidad (2x2) multiplicada por invSigma2, la inversa cuadrada del factor de escala que corresponde al nivel de pirámide en el que se observó el punto. Esto significa que a mayor nivel de la pirámide, más difusa es la posición del punto.</p>
<p>Aplica a la observación del punto (el punto singular 2D).</p>
<p>El factor de escala se aplica a las coordenadas en píxeles: un factor de escala 1,2 significa un error de 1,2 píxeles en la medición.</p>
<p>Vértices:</p><ul>
<li><a class="el" href="classg2o_1_1_vertex_s_e3_expmap.html" title="SE3 Vertex parameterized internally with a transformation matrix and externally with its exponential ...">g2o::VertexSE3Expmap</a>: pose de keyframe</li>
<li><a class="el" href="classg2o_1_1_vertex_s_b_a_point_x_y_z.html" title="Point vertex, XYZ. ">g2o::VertexSBAPointXYZ</a>: posición del mappoint</li>
</ul>
<p>Ejes:</p><ul>
<li><a class="el" href="classg2o_1_1_edge_s_e3_project_x_y_z.html">g2o::EdgeSE3ProjectXYZ</a><ul>
<li>vértice 0: mappoint</li>
<li>vértice 1: keyframe</li>
<li>medición: coordenadas del keypoint</li>
<li>información: invSigma2 de la octava del keypoint </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a5a53ab409feed7f92547eb79a2d7f6e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::Optimizer::OptimizeEssentialGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html">Map</a> *&#160;</td>
          <td class="paramname"><em>pMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pLoopKF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pCurKF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#ae9ada143a8308ce32990a7c7b5d533ab">LoopClosing::KeyFrameAndPose</a> &amp;&#160;</td>
          <td class="paramname"><em>NonCorrectedSim3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#ae9ada143a8308ce32990a7c7b5d533ab">LoopClosing::KeyFrameAndPose</a> &amp;&#160;</td>
          <td class="paramname"><em>CorrectedSim3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *, set&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>LoopConnections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>bFixScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optimiza el grafo esencial para cerrar un bucle. </p>
<p>El cierre de bucle se realiza según se describe en el paper Scale Drift-Aware Large Scale Monocular SLAM, Strasdat et al, 2010.</p>
<p>La corrección minimizando el error de las transformaciones sim3 se describe en IV.B.Loop Closure Correction (24).</p>
<p>Realiza una corrección de pose solamente (en sim3) minimizando la diferencia (o error) entre las transformaciones originales con drifting y las propuestas que cierran el bucle, sin considerar los puntos observados.</p>
<p>Al detectar un cierre de bucle, se unen los extremos.</p>
<p>Este método realiza un "pose graph optimization"; ejecuta un BA para repartir el error cuadrático medio a lo largo del grafo esencial. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMap</td><td>Mapa completo. </td></tr>
    <tr><td class="paramname">pLoopKF</td><td>Keyframe del extremo anterior del bucle. </td></tr>
    <tr><td class="paramname">pCurKF</td><td>Keyframe actual, del extremo posterior del bucle. </td></tr>
    <tr><td class="paramname">NonCorrectedSim3</td><td>KeyframeAndPose de los keyframes actual y vecinos, versión sin transformar sim3. </td></tr>
    <tr><td class="paramname">CorrectedSim3</td><td>KeyframeAndPose de los keyframes vecinos, versión corregida por sim3. </td></tr>
    <tr><td class="paramname">LoopConnections</td><td>Conjunto de keyframes conectados gracias al cierre del bucle. Para cada keyframe que cierra el bucle, asocia un conjunto de keyframes asociados del otro lado del bucle. </td></tr>
    <tr><td class="paramname">bFixScale</td><td>false para monocular. Si es true computa sobre 6 grados de libertad, si es false sobre 7 grados de libertad (porque incluye escala).</td></tr>
  </table>
  </dd>
</dl>
<p>Este método se invoca exclusivamente en la etapa final de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#aa007e0678582ec0de5d71280d23af540" title="Corrige el bucle con los encastres elaborados por LoopClosing::ComputeSim3. ">LoopClosing::CorrectLoop()</a>.</p>
<p>Carga en el optimizador todos los keyframes del mapa, marcando como fijo solamente al del extremo anterior del bucle. Carga todos los ejes del mapa: las conexiones entre keyframes, agregando las nuevas conexiones del bucle informadas en loopConnections. Ejecuta 20 iteraciones, y vuelca el resultado a las poses de los keyframes y de las posiciones de los puntos, recomputando normal y profundidad.</p>
<p>El optimizador se arma así: </p><pre class="fragment">typedef  BlockSolver&lt; BlockSolverTraits&lt; 7, 3 &gt; &gt; BlockSolver_7_3;
g2o::SparseOptimizer optimizer;
g2o::OptimizationAlgorithmLevenberg* solver = new g2o::OptimizationAlgorithmLevenberg(
    new g2o::BlockSolver_7_3(
        new g2o::LinearSolverEigen&lt;g2o::BlockSolver_7_3::PoseMatrixType&gt;()
    )
);
solver-&gt;setUserLambdaInit(1e-16);
optimizer.setAlgorithm(solver);
</pre><p>PoseMatrixType significa que para el hessiano de puntos se usan matrices double de 3x3, y para el hessiano de poses matrices double de 7x7. Este código significa: optimizador espaciado, con algoritmo LM, solucionador de bloque para poses de 7 dimensiones y puntos de 3 dimensiones, usando Cholesky espaciado de la librería Eigen.</p>
<p>A diferencia de PoseOptimization y LocalBundleAdjustment, se usa un BlockSolver_7_3 en lugar del BlockSolverX, y se le ajusta el LambdaInit.</p>
<p>Vértices:</p><ul>
<li><a class="el" href="classg2o_1_1_vertex_sim3_expmap.html" title="Sim3 Vertex, (x,y,z,qw,qx,qy,qz) the parameterization for the increments constructed is a 7d vector (...">g2o::VertexSim3Expmap</a>: pose de keyframe</li>
</ul>
<p>Ejes:</p><ul>
<li><a class="el" href="classg2o_1_1_edge_sim3.html" title="7D edge between two Vertex7 ">g2o::EdgeSim3</a>: ejes entre dos poses de keyframes</li>
<li>medición: <a class="el" href="structg2o_1_1_sim3.html">g2o::Sim3</a>, pose relativa entre dos keyframes</li>
<li>información: 1 </li>
</ul>

</div>
</div>
<a id="a5158a64390b806687666c1e93425120d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::Optimizer::OptimizeSim3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>vpMatches1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structg2o_1_1_sim3.html">g2o::Sim3</a> &amp;&#160;</td>
          <td class="paramname"><em>g2oS12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>th2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Depura la transformación sim3 (espacio de transformaciones de similaridad, de 7 dimensiones) entre dos keyframes, que mejor explica un macheo. </p>
<p>Dados dos keyframes que presumiblemente observan lo mismmo y son candidatos a cierre de bucle, y dada una serie de puntos macheados observados por ambos keyframes, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#a5158a64390b806687666c1e93425120d" title="Depura la transformación sim3 (espacio de transformaciones de similaridad, de 7 dimensiones) entre do...">OptimizeSim3()</a> calcula la transformación de similaridad sim3 que compatibiliza ambas visualizaciones y permite cerrar el bucle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF1</td><td><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a> actual, candidato a cerrar el bucle. </td></tr>
    <tr><td class="paramname">pKF2</td><td><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a> preexistente, el otro extremo el bucle. </td></tr>
    <tr><td class="paramname">vpMatches1</td><td>Puntos 3D observados desde ambos keyframes. </td></tr>
    <tr><td class="paramname">g2oS12</td><td>Estimación inicial y resultado, transformación sim3 que alinea los keyframes. </td></tr>
    <tr><td class="paramname">th2</td><td>Umbral, siempre 10. </td></tr>
    <tr><td class="paramname">bFixScale</td><td>Siempre false para monocular.</td></tr>
  </table>
  </dd>
</dl>
<p>ESte método se invoca exclusivamente desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#ab4fcf814eed5b5dd2aec96454561b078" title="Procesa la lista de candidatos intentando corregir su pose. ">LoopClosing::ComputeSim3()</a>.</p>
<p>El optimizador se arma así: </p><pre class="fragment">    g2o::SparseOptimizer optimizer;
    optimizer.setAlgorithm(
        new g2o::OptimizationAlgorithmLevenberg(
            new g2o::BlockSolverX(
                new g2o::LinearSolverDense&lt;g2o::BlockSolverX::PoseMatrixType&gt;()
            )
        )
    );
</pre><p>Vértices:</p><ul>
<li><a class="el" href="classg2o_1_1_vertex_sim3_expmap.html" title="Sim3 Vertex, (x,y,z,qw,qx,qy,qz) the parameterization for the increments constructed is a 7d vector (...">g2o::VertexSim3Expmap</a>: pose sim3 entre ambos keyframe. Único vertex a optimizar</li>
<li><a class="el" href="classg2o_1_1_vertex_s_b_a_point_x_y_z.html" title="Point vertex, XYZ. ">g2o::VertexSBAPointXYZ</a>: posición de los mappoints</li>
</ul>
<p>Ejes:</p><ul>
<li><a class="el" href="classg2o_1_1_edge_sim3_project_x_y_z.html">g2o::EdgeSim3ProjectXYZ</a>: eje del keyframe a un mappoint</li>
<li><a class="el" href="classg2o_1_1_edge_inverse_sim3_project_x_y_z.html">g2o::EdgeInverseSim3ProjectXYZ</a>: eje de un mappoint al keyframe</li>
</ul>
<p>Las poses son <a class="el" href="classg2o_1_1_vertex_sim3_expmap.html" title="Sim3 Vertex, (x,y,z,qw,qx,qy,qz) the parameterization for the increments constructed is a 7d vector (...">g2o::VertexSim3Expmap</a> en lugar de VertexSE3Expmap, pues son poses de similaridad (sim3) en lugar de rototraslación (SE3, Special Euclidean). Expmap son mapas exponenciales.</p>
<p>Las posiciones de los puntos son <a class="el" href="classg2o_1_1_vertex_s_b_a_point_x_y_z.html" title="Point vertex, XYZ. ">g2o::VertexSBAPointXYZ</a>, como en todos los BA.</p>
<p>Los ejes van de a pares, en ambos sentidos, y son de tipos <a class="el" href="classg2o_1_1_edge_sim3_project_x_y_z.html">g2o::EdgeSim3ProjectXYZ</a> y <a class="el" href="classg2o_1_1_edge_inverse_sim3_project_x_y_z.html">g2o::EdgeInverseSim3ProjectXYZ</a>.</p>
<p>OptimizeSim3 construye un vertex VertexSim3Expmap, consituido por una transformación de similaridad inicial que explica las poses entre dos keyframes. Es el único vertex a optimizar.</p>
<p>El resto de los vertex son fijos, corresponden a los puntos 3D observados desde el pKF2 (el keyframe preexistente).</p>
<p>De este modo la transformación resultante es la que se aplicará al keyframe actual para cerrar el bucle. </p>

</div>
</div>
<a id="a7415d78b8a2323b88e108fa1ea3bf2d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::Optimizer::PoseOptimization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> *&#160;</td>
          <td class="paramname"><em>pFrame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cómputo de la pose de un cuadro. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pFrame</td><td>Calcula la pose del frame a partir de los puntos observados y sus posiciones en el mapa. La pose es una matriz de rototraslación de 4x4 en coordenadas homogéneas. Usa la pose del cuadro pFrame-&gt;mTcw como estimación inicial, usualmente la estimada por el modelo de movimiento, aunque puede también ser recuperada por relocalización. Éste es el único método que calcula la pose final de un cuadro. Se invoca para cada cuadro. Las poses de los cuadros son establecidas principalmente por este método, aunque también otros métodos (de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html" title="Objeto único que se ejecuta en su propio Trhead, y se inicia con Run(). ">Tracking</a>) inicializan la pose, la copian o estiman por modelo de movimiento.</td></tr>
    <tr><td class="paramname">pFrame</td><td>Cuadro con macheos contra puntos del mapa, cuya pose se quiere calcular. La pose se guarda en pFrame-&gt;mTcw. En OrbSlam siempre es el cuadro actual. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>La cantidad de correspondencias optimizadas (macheos sobrevivientes, inliers).</dd></dl>
<p>El optimizador se arma así:</p>
<p><a class="el" href="classg2o_1_1_sparse_optimizer.html">g2o::SparseOptimizer</a> optimizer; optimizer.setAlgorithm( new <a class="el" href="classg2o_1_1_optimization_algorithm_levenberg.html" title="Implementation of the Levenberg Algorithm. ">g2o::OptimizationAlgorithmLevenberg</a>( new <a class="el" href="namespaceg2o.html#a8d3214273331c25cbb5d5266770e6c12">g2o::BlockSolverX</a>( new g2o::LinearSolverDense&lt;g2o::BlockSolverX::PoseMatrixType&gt;() ) ) );</p>
<p>Único vértice:</p><ul>
<li><a class="el" href="classg2o_1_1_vertex_s_e3_expmap.html" title="SE3 Vertex parameterized internally with a transformation matrix and externally with its exponential ...">g2o::VertexSE3Expmap</a>: pose del frame</li>
</ul>
<p>Ejes de un sólo vértice común:</p><ul>
<li><a class="el" href="classg2o_1_1_edge_s_e3_project_x_y_z_only_pose.html">g2o::EdgeSE3ProjectXYZOnlyPose</a></li>
<li><a class="el" href="classg2o_1_1_robust_kernel_huber.html" title="Huber Cost Function. ">g2o::RobustKernelHuber</a>, delta sqrt(5.991)</li>
<li>medición: coordenadas del keypoint</li>
<li>información: invSigma2 de la octava</li>
<li>xW: coordenadas del mappoint</li>
<li>matriz de calibración </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/alejandro/Desarrollo eclipse/os1/include/<a class="el" href="_optimizer_8h_source.html">Optimizer.h</a></li>
<li>/home/alejandro/Desarrollo eclipse/os1/src/<a class="el" href="_optimizer_8cc.html">Optimizer.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_o_r_b___s_l_a_m2.html">ORB_SLAM2</a></li><li class="navelem"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html">Optimizer</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
