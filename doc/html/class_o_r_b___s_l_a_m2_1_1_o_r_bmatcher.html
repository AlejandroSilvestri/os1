<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Os1: ORB_SLAM2::ORBmatcher Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Os1
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">OrbSlam2 documentado y modificado</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,'Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ORB_SLAM2::ORBmatcher Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html" title="ORBmatcher empaqueta todos los métodos de macheo de descriptores. ">ORBmatcher</a> empaqueta todos los métodos de macheo de descriptores.  
 <a href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_o_r_bmatcher_8h_source.html">ORBmatcher.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:add796fcf9f5cae91393d4c0b767e0183"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#add796fcf9f5cae91393d4c0b767e0183">Fuse</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF, const vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;vpMapPoints, const float th=3.0)</td></tr>
<tr class="memdesc:add796fcf9f5cae91393d4c0b767e0183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proyecta puntos del mapa sobre un keyframe y busca puntos duplicados, como parte del mapeo local.  <a href="#add796fcf9f5cae91393d4c0b767e0183">More...</a><br /></td></tr>
<tr class="separator:add796fcf9f5cae91393d4c0b767e0183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16efd376a838e1edf18c04229b86059d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#a16efd376a838e1edf18c04229b86059d">Fuse</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF, cv::Mat Scw, const std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;vpPoints, float th, vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;vpReplacePoint)</td></tr>
<tr class="memdesc:a16efd376a838e1edf18c04229b86059d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fusiona los puntos del mapa para cerrar un bucle.  <a href="#a16efd376a838e1edf18c04229b86059d">More...</a><br /></td></tr>
<tr class="separator:a16efd376a838e1edf18c04229b86059d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca536b80e44da0f56fcd35ff8c6a833"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#a6ca536b80e44da0f56fcd35ff8c6a833">ORBmatcher</a> (float nnratio=0.6, bool checkOri=true)</td></tr>
<tr class="memdesc:a6ca536b80e44da0f56fcd35ff8c6a833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor que guarda los argumentos en propiedades.  <a href="#a6ca536b80e44da0f56fcd35ff8c6a833">More...</a><br /></td></tr>
<tr class="separator:a6ca536b80e44da0f56fcd35ff8c6a833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024fe40fa89785df914ef0a59cdf605d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#a024fe40fa89785df914ef0a59cdf605d">SearchByBoW</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;F, std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;vpMapPointMatches)</td></tr>
<tr class="memdesc:a024fe40fa89785df914ef0a59cdf605d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Machea puntos del cuadro actual con los de un keyframe.  <a href="#a024fe40fa89785df914ef0a59cdf605d">More...</a><br /></td></tr>
<tr class="separator:a024fe40fa89785df914ef0a59cdf605d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62ee37a7d926719f16ddd17f7e48e10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#ad62ee37a7d926719f16ddd17f7e48e10">SearchByBoW</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF1, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF2, std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;vpMatches12)</td></tr>
<tr class="memdesc:ad62ee37a7d926719f16ddd17f7e48e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evalúa keyframe candidato para cierre de bucle.  <a href="#ad62ee37a7d926719f16ddd17f7e48e10">More...</a><br /></td></tr>
<tr class="separator:ad62ee37a7d926719f16ddd17f7e48e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43d042858a3a3ca4238bb4ca519f196"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#ae43d042858a3a3ca4238bb4ca519f196">SearchByProjection</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;F, const std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;vpMapPoints, const float th=3)</td></tr>
<tr class="memdesc:ae43d042858a3a3ca4238bb4ca519f196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macheo en ventana cuadrada entre puntos singulares detectados en el cuadro actual, y la proyección de los puntos del mapa que deberían ser vistos.  <a href="#ae43d042858a3a3ca4238bb4ca519f196">More...</a><br /></td></tr>
<tr class="separator:ae43d042858a3a3ca4238bb4ca519f196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa0921aedad59335052ecb2bc583dfe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#a5aa0921aedad59335052ecb2bc583dfe">SearchByProjection</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;CurrentFrame, const <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;LastFrame, const float th)</td></tr>
<tr class="memdesc:a5aa0921aedad59335052ecb2bc583dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macheo en ventana cuadrada entre descriptores de puntos singulares del cuadro actual con los puntos singulares del cuadro anterior asociados a algún punto del mapa local.  <a href="#a5aa0921aedad59335052ecb2bc583dfe">More...</a><br /></td></tr>
<tr class="separator:a5aa0921aedad59335052ecb2bc583dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83a014848a63b5a3b3086386f7a865e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#af83a014848a63b5a3b3086386f7a865e">SearchByProjection</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;CurrentFrame, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF, const std::set&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;sAlreadyFound, const float th, const int ORBdist)</td></tr>
<tr class="memdesc:af83a014848a63b5a3b3086386f7a865e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Busca en el cuadro actual los puntos vistos en el keyFrame candidato para relocalización.  <a href="#af83a014848a63b5a3b3086386f7a865e">More...</a><br /></td></tr>
<tr class="separator:af83a014848a63b5a3b3086386f7a865e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c0dcdeed922c9a96760aa9a76a2fdb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#ac1c0dcdeed922c9a96760aa9a76a2fdb">SearchByProjection</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF, cv::Mat Scw, const std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;vpPoints, std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;vpMatched, int th)</td></tr>
<tr class="memdesc:ac1c0dcdeed922c9a96760aa9a76a2fdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ante una detección de bucle con varios macheos y una pose propuesta, este método aumenta la cantidad de macheos comparando contra otros puntos que deberían ser vistos desde el keyframe actual.  <a href="#ac1c0dcdeed922c9a96760aa9a76a2fdb">More...</a><br /></td></tr>
<tr class="separator:ac1c0dcdeed922c9a96760aa9a76a2fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9c641423a8075aa2a6f1d5bab4d211"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#a9b9c641423a8075aa2a6f1d5bab4d211">SearchBySim3</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF1, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF2, std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;vpMatches12, const float &amp;s12, const cv::Mat &amp;R12, const cv::Mat &amp;t12, const float th)</td></tr>
<tr class="memdesc:a9b9c641423a8075aa2a6f1d5bab4d211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compara dos keyframes candidatos al cierre de bucle y buscando aumentar los puntos macheados por aspecto.  <a href="#a9b9c641423a8075aa2a6f1d5bab4d211">More...</a><br /></td></tr>
<tr class="separator:a9b9c641423a8075aa2a6f1d5bab4d211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9b6dde7878d59e334ed5ad2ddd04eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#aff9b6dde7878d59e334ed5ad2ddd04eb">SearchForInitialization</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;F1, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;F2, std::vector&lt; cv::Point2f &gt; &amp;vbPrevMatched, std::vector&lt; int &gt; &amp;vnMatches12, int windowSize=10)</td></tr>
<tr class="memdesc:aff9b6dde7878d59e334ed5ad2ddd04eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macheo para inicialización.  <a href="#aff9b6dde7878d59e334ed5ad2ddd04eb">More...</a><br /></td></tr>
<tr class="separator:aff9b6dde7878d59e334ed5ad2ddd04eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3feb387bd622e78dc8f596f90726d1c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#a3feb387bd622e78dc8f596f90726d1c4">SearchForTriangulation</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF1, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF2, cv::Mat F12, std::vector&lt; pair&lt; size_t, size_t &gt; &gt; &amp;vMatchedPairs)</td></tr>
<tr class="memdesc:a3feb387bd622e78dc8f596f90726d1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Machea puntos singulares entre el keyframe actual y un vecino, con el propósito posterior de triangular nuevos puntos y agregarlos al mapa.  <a href="#a3feb387bd622e78dc8f596f90726d1c4">More...</a><br /></td></tr>
<tr class="separator:a3feb387bd622e78dc8f596f90726d1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a63ff10561753f23220c2bfcea9b599f3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#a63ff10561753f23220c2bfcea9b599f3">DescriptorDistance</a> (const cv::Mat &amp;a, const cv::Mat &amp;b)</td></tr>
<tr class="memdesc:a63ff10561753f23220c2bfcea9b599f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcula la distancia de Hamming entre dos descriptores, con el algoritmo de Stanford.  <a href="#a63ff10561753f23220c2bfcea9b599f3">More...</a><br /></td></tr>
<tr class="separator:a63ff10561753f23220c2bfcea9b599f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa2f2d9094b4f31db4f65c93778f71494"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#aa2f2d9094b4f31db4f65c93778f71494">HISTO_LENGTH</a> = 30</td></tr>
<tr class="memdesc:aa2f2d9094b4f31db4f65c93778f71494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tamaño del array de histograma.  <a href="#aa2f2d9094b4f31db4f65c93778f71494">More...</a><br /></td></tr>
<tr class="separator:aa2f2d9094b4f31db4f65c93778f71494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb28265794388e19763e9a3dabd51473"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#aeb28265794388e19763e9a3dabd51473">TH_HIGH</a> = 100</td></tr>
<tr class="memdesc:aeb28265794388e19763e9a3dabd51473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Umbral alto, laxo, para distancias entre descriptores.  <a href="#aeb28265794388e19763e9a3dabd51473">More...</a><br /></td></tr>
<tr class="separator:aeb28265794388e19763e9a3dabd51473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810252607722e100efe4c4e941ae00a6"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#a810252607722e100efe4c4e941ae00a6">TH_LOW</a> = 50</td></tr>
<tr class="memdesc:a810252607722e100efe4c4e941ae00a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Umbral bajo, estricto, para distancias entre descriptores.  <a href="#a810252607722e100efe4c4e941ae00a6">More...</a><br /></td></tr>
<tr class="separator:a810252607722e100efe4c4e941ae00a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a10df000eeb05466a5bbfd7b40c7db45d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#a10df000eeb05466a5bbfd7b40c7db45d">CheckDistEpipolarLine</a> (const cv::KeyPoint &amp;kp1, const cv::KeyPoint &amp;kp2, const cv::Mat &amp;F12, const <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF)</td></tr>
<tr class="memdesc:a10df000eeb05466a5bbfd7b40c7db45d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comprobación por línea epipolar.  <a href="#a10df000eeb05466a5bbfd7b40c7db45d">More...</a><br /></td></tr>
<tr class="separator:a10df000eeb05466a5bbfd7b40c7db45d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6613e26706798c507b5266cdd101311"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#ad6613e26706798c507b5266cdd101311">ComputeThreeMaxima</a> (std::vector&lt; int &gt; *histo, const int L, int &amp;ind1, int &amp;ind2, int &amp;ind3)</td></tr>
<tr class="memdesc:ad6613e26706798c507b5266cdd101311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computa 3 máximos.  <a href="#ad6613e26706798c507b5266cdd101311">More...</a><br /></td></tr>
<tr class="separator:ad6613e26706798c507b5266cdd101311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ae0904b9919f1141ef4a790cd34bfe"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#ae6ae0904b9919f1141ef4a790cd34bfe">RadiusByViewingCos</a> (const float &amp;viewCos)</td></tr>
<tr class="memdesc:ae6ae0904b9919f1141ef4a790cd34bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empaqueta la decisión del radio en búsqueda en ventana caudrada, según el coseno de la triangulación.  <a href="#ae6ae0904b9919f1141ef4a790cd34bfe">More...</a><br /></td></tr>
<tr class="separator:ae6ae0904b9919f1141ef4a790cd34bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a996a27217749aa15d2210c6dc6228495"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#a996a27217749aa15d2210c6dc6228495">mbCheckOrientation</a></td></tr>
<tr class="memdesc:a996a27217749aa15d2210c6dc6228495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Señal interna de configuración definida en la construcción del objeto, que indica si se debe chequear la orientación antes de comparar descriptores.  <a href="#a996a27217749aa15d2210c6dc6228495">More...</a><br /></td></tr>
<tr class="separator:a996a27217749aa15d2210c6dc6228495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f6ee66568fa5a79600ed5ad8443893"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#a08f6ee66568fa5a79600ed5ad8443893">mfNNratio</a></td></tr>
<tr class="memdesc:a08f6ee66568fa5a79600ed5ad8443893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nearest neighbor ratio.  <a href="#a08f6ee66568fa5a79600ed5ad8443893">More...</a><br /></td></tr>
<tr class="separator:a08f6ee66568fa5a79600ed5ad8443893"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html" title="ORBmatcher empaqueta todos los métodos de macheo de descriptores. ">ORBmatcher</a> empaqueta todos los métodos de macheo de descriptores. </p>
<p>Las pocas propiedades son protegidas, corresponden a la configuración establecida en la construcción. No confundir con la clase <a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html" title="Empaqueta todos los métodos de detección de puntos singulares y extracción de descriptores. ">ORBextractor</a>, de nombre similar, que empaqueta todos los métodos de extracción de descriptores. Todos los métodos son invocados desde otros objetos. Solamente DescriptorDistance, que computa la distancia entre dos descriptores con el algoritmo de Stanford, es invocado también internamente por prácticamente todos los otros métodos de ORBMatcher.</p>
<p>Mientras <a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html" title="Empaqueta todos los métodos de detección de puntos singulares y extracción de descriptores. ">ORBextractor</a> se ocupa de detectar puntos singulares y extraer descriptores ORB, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html" title="ORBmatcher empaqueta todos los métodos de macheo de descriptores. ">ORBmatcher</a> se ocupa de machear de diversas maneras:</p>
<ul>
<li>SearchByProjection parte de una pose, proyecta los puntos del mapa local que deberían ser visibles, y realiza un macheo circular. Hay 4 SearchByProjection especializados en:<ul>
<li>puntos rastreados</li>
<li>puntos proyectados no rastreados</li>
<li>candidatos para relocalización</li>
<li>candidatos para cierre de bucle</li>
</ul>
</li>
<li>SearchByBoW machea primero por BoW, y luego por descriptores cuando hay varios candidatos con el mismo BoW.</li>
<li>SearchForInitialization machea para encontrar los primeros puntos del mapa.</li>
<li>SearchForTriangulation machea para encontrar nuevos puntos 3D.</li>
<li>SearchBySim3 machea para evaluar candidatos a cierre de bucle.</li>
<li>Fuse fusiona puntos del mapa duplicados. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6ca536b80e44da0f56fcd35ff8c6a833"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORB_SLAM2::ORBmatcher::ORBmatcher </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>nnratio</em> = <code>0.6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkOri</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor que guarda los argumentos en propiedades. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nnratio</td><td>Nearest Neighbour ratio. Indica la relación entre el mejor y peor candidato a brindar como resultado. </td></tr>
    <tr><td class="paramname">checkOri</td><td>Check Orientation. true para comprobar la orientación de cada punto antes de evaluar el macheo (true por defecto). Además lleva un histórico de orientaciones. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a10df000eeb05466a5bbfd7b40c7db45d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ORB_SLAM2::ORBmatcher::CheckDistEpipolarLine </td>
          <td>(</td>
          <td class="paramtype">const cv::KeyPoint &amp;&#160;</td>
          <td class="paramname"><em>kp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::KeyPoint &amp;&#160;</td>
          <td class="paramname"><em>kp2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>F12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Comprobación por línea epipolar. </p>
<p>Comprueba si un puntos singulares de una pose, están en (o muy cerca) de la línea epipolar de otro punto singular de otra pose.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kp1</td><td>Punto singular de la pose 1. </td></tr>
    <tr><td class="paramname">kp2</td><td>Punto singular de la pose 2. </td></tr>
    <tr><td class="paramname">F12</td><td>Matriz fundamental entre ambas poses. </td></tr>
    <tr><td class="paramname">pKF1</td><td>Keyframe 1 (pose 1). </td></tr>
    <tr><td class="paramname">pKF2</td><td>Keyframe 2 (pose 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Señal que indica que los puntos tienen correspondencia epipolar.</dd></dl>
<p>Invocada solo de SearchForTriangulation, con puntos singulares macheados. </p>

</div>
</div>
<a id="ad6613e26706798c507b5266cdd101311"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::ORBmatcher::ComputeThreeMaxima </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>histo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ind1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ind2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>ind3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computa 3 máximos. </p>
<p>Recorre los vectores del histograma, comparando sus longitudes, y devuelve los índices de los tres vectores de mayor cantidad de elementos.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">histo</td><td>Histograma, array de vectores de int. Siempre creado como <code>vector&lt;int&gt; rotHist[HISTO_LENGTH];</code>. </td></tr>
    <tr><td class="paramname">L</td><td>Longitud, cantidad de elementos de histo. Siempre es HISTO_LENGTH. </td></tr>
    <tr><td class="paramname">ind1</td><td>Índice del histotrama de mayor longitud. Valor resultado, uno de los 3 máximos. Siempre se pasa inicializado en -1. </td></tr>
    <tr><td class="paramname">ind2</td><td>Índice del histotrama de segunda mayor longitud. Valor resultado, uno de los 3 máximos. Siempre se pasa inicializado en -1. </td></tr>
    <tr><td class="paramname">ind3</td><td>Índice del histotrama de tercera mayor longitud. Valor resultado, uno de los 3 máximos. Siempre se pasa inicializado en -1.</td></tr>
  </table>
  </dd>
</dl>
<p>Este método se invoca sólo desde otros métodos de la misma clase. Todos ellos inicializan <code>int1=int2=int3=-1</code>. </p>

</div>
</div>
<a id="a63ff10561753f23220c2bfcea9b599f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::ORBmatcher::DescriptorDistance </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calcula la distancia de Hamming entre dos descriptores, con el algoritmo de Stanford. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Descriptor A. </td></tr>
    <tr><td class="paramname">b</td><td>Descriptor B. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>La distancia entre los dos descriptores binarios. </dd></dl>

</div>
</div>
<a id="add796fcf9f5cae91393d4c0b767e0183"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::ORBmatcher::Fuse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>vpMapPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>th</em> = <code>3.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Proyecta puntos del mapa sobre un keyframe y busca puntos duplicados, como parte del mapeo local. </p>
<p>Fusiona puntos del mapa que corresponden al mismo punto real. Se utiliza dos veces: proyectando los puntos del keyframe actual sobre los keyframes vecinos, y viceversa. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF</td><td>Keyframe donde se proyectarán los puntos del mapa. </td></tr>
    <tr><td class="paramname">vpMapPoints</td><td>Puntos del mapa observados en un keyframe vecino. </td></tr>
    <tr><td class="paramname">th</td><td>Radio de búsqueda circular. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cantidad de puntos fusionados.</dd></dl>
<p>Invocado dos veces sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_local_mapping.html#a5d5e0bc6fd15d9a6bf1ca8a258f104f1" title="Recorre los keyframes vecinos buscando puntos para fusionar. ">LocalMapping::SearchInNeighbors</a>. </p>

</div>
</div>
<a id="a16efd376a838e1edf18c04229b86059d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::ORBmatcher::Fuse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>Scw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>vpPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>vpReplacePoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fusiona los puntos del mapa para cerrar un bucle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF</td><td>Keyframe actual o vecino de un extremo del bucle cerrado. </td></tr>
    <tr><td class="paramname">Scw</td><td>Pose sim3 de la cámara respecto del mundo. Este argumento requiere mayor investigación. </td></tr>
    <tr><td class="paramname">vpPoints</td><td>Puntos del mapa observados por el keyframe del otro extremo del bucle, y sus vecinos. </td></tr>
    <tr><td class="paramname">th</td><td>Radio para el macheo circular. </td></tr>
    <tr><td class="paramname">vpReplacePoint</td><td>Resultado del método, puntos fusionados. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cantidad de puntos fusionados.</dd></dl>
<p>Invocado sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#aabe9d9b913f36b607c67b0ed0df42a1d" title="Proyecta los puntos observados en la vecindad del keyframe del bucle, sobre el keyframe actual y veci...">LoopClosing::SearchAndFuse</a> </p>

</div>
</div>
<a id="ae6ae0904b9919f1141ef4a790cd34bfe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ORB_SLAM2::ORBmatcher::RadiusByViewingCos </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>viewCos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empaqueta la decisión del radio en búsqueda en ventana caudrada, según el coseno de la triangulación. </p>
<p>A mayor paralaje, menor radio, la búsqueda será más estricta. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewCos</td><td>Coseno del ángulo de visión del punto.</td></tr>
  </table>
  </dd>
</dl>
<p>Invocado sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#ae43d042858a3a3ca4238bb4ca519f196" title="Macheo en ventana cuadrada entre puntos singulares detectados en el cuadro actual, y la proyección de los puntos del mapa que deberían ser vistos. ">ORBmatcher::SearchByProjection</a> entre keyframe y mapa. </p>

</div>
</div>
<a id="a024fe40fa89785df914ef0a59cdf605d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::ORBmatcher::SearchByBoW </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>vpMapPointMatches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Machea puntos del cuadro actual con los de un keyframe. </p>
<p>Macheo de fuerza bruta, primero por BoW y luego por descriptores.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF</td><td>Keyframe candidato a explicar el cuadro actual. Es el keyframe de referencia para tracking, o uno de varios candidatos en relocalización. </td></tr>
    <tr><td class="paramname">F</td><td>Cuadro actual que se intenta ubicar. </td></tr>
    <tr><td class="paramname">vpMapPointMatches</td><td>Resultado, puntos 3D macheados. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cantidad de puntos macheados.</dd></dl>
<p>Invocado sólo por <a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html#acd4ea9e7097bed16428a4b78fe4b6a67" title="Dispara una relocalización. ">Tracking::Relocalization</a> y Tracking::TrackByReferencieKeyFrame. </p>

</div>
</div>
<a id="ad62ee37a7d926719f16ddd17f7e48e10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::ORBmatcher::SearchByBoW </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>vpMatches12</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evalúa keyframe candidato para cierre de bucle. </p>
<p>Machea por BoW y luego por descriptores. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF1</td><td>Keyframe actual. </td></tr>
    <tr><td class="paramname">pKF2</td><td>Keyframe candidato al cierre de bucle. </td></tr>
    <tr><td class="paramname">vpMatches12</td><td>Resultado de la búsqueda, puntos del mapa macheados. Es un vector alineado con el vector de puntos de pKF1, conteniendo los puntos macheados por BoW y descriptores, observador por pKF2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cantidad de macheos.</dd></dl>
<p>Invocado sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#ab4fcf814eed5b5dd2aec96454561b078" title="Procesa la lista de candidatos intentando corregir su pose. ">LoopClosing::ComputeSim3</a>. </p>

</div>
</div>
<a id="ae43d042858a3a3ca4238bb4ca519f196"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::ORBmatcher::SearchByProjection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>vpMapPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>th</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macheo en ventana cuadrada entre puntos singulares detectados en el cuadro actual, y la proyección de los puntos del mapa que deberían ser vistos. </p>
<p>Evita reprocesar los puntos que ya fueron vistos en LastFrame y que han sido asignados al cuadro actual en TrackWithMotionModel.</p>
<p>Estos puntos tienen la marca efímera <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html#a0187350fa3fddd0bf89ccf354acb4766">MapPoint::mbTrackInView</a>.</p>
<p>Agrega los puntos nuevos al registro de puntos vistos del cuadro actual mvpMapPoints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td>Cuadro actual </td></tr>
    <tr><td class="paramname">vpMapPoints</td><td>Mapa local </td></tr>
    <tr><td class="paramname">th</td><td>Threshold, umbral, base para calcular el radio de búsqueda. Es 1, excepto luego de una relocalización, que es 5. El radio se obtiene multiplicando th * <a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html#ae6ae0904b9919f1141ef4a790cd34bfe" title="Empaqueta la decisión del radio en búsqueda en ventana caudrada, según el coseno de la triangulación...">ORBmatcher::RadiusByViewingCos</a>, que normalmente es 4, pero es 2,5 cuando no hay paralaje.</td></tr>
  </table>
  </dd>
</dl>
<p>Invocado exclusivamente desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html#a451c0e5372c24645c7634fcebc8fa847" title="Invocado por TrackLocalMap. ">Tracking::SearchLocalPoints</a>. </p>

</div>
</div>
<a id="a5aa0921aedad59335052ecb2bc583dfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::ORBmatcher::SearchByProjection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;&#160;</td>
          <td class="paramname"><em>CurrentFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;&#160;</td>
          <td class="paramname"><em>LastFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>th</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macheo en ventana cuadrada entre descriptores de puntos singulares del cuadro actual con los puntos singulares del cuadro anterior asociados a algún punto del mapa local. </p>
<p>Crea la lista de puntos del mapa local vistos desde el cuadro actual CurrentFrame.mvpMapPoints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CurrentFrame</td><td>Cuadro actual, con sus puntos singulares detectados. </td></tr>
    <tr><td class="paramname">LastFrame</td><td>Cuadro anterior, con sus puntos singulares y sus puntos de mapa local asociados. </td></tr>
    <tr><td class="paramname">th</td><td>Umbral que determina el radio del área donde machear. El radio dependerá el nivel de la pirámide donde se busque.</td></tr>
  </table>
  </dd>
</dl>
<p>Se invoca con 15, y si se consiguieron pocos macheos se repite con 30.</p>
<ol type="1">
<li>Aplica el modelo de movimiento para pronosticar una pose.</li>
<li>Proyecta puntos del mapa detectados en LastFrame.</li>
<li>Machea descriptores entre los puntos singulares de CurrentFrame encontrados en una región circular con centro en la proyección.</li>
<li>Asocia los puntos 3D macheados a los puntos singulares en CurrentFrame.</li>
</ol>
<p>Este método no corrige pose, sólo asocia puntos singulares macheados en una región circular. No verifica coherencia.</p>
<p>Invocado exclusivamente desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html#aca19f1d69b30a6c6e49281d422ac8298" title="SfM. ">Tracking::TrackWithMotionModel</a>, que a partir de este macheo computa la pose del cuadro actual. </p>

</div>
</div>
<a id="af83a014848a63b5a3b3086386f7a865e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::ORBmatcher::SearchByProjection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;&#160;</td>
          <td class="paramname"><em>CurrentFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>sAlreadyFound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ORBdist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Busca en el cuadro actual los puntos vistos en el keyFrame candidato para relocalización. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CurrentFrame</td><td>Cuadro actual. </td></tr>
    <tr><td class="paramname">pKF</td><td><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a> candidato para relocalización. </td></tr>
    <tr><td class="paramname">AlreadyFound</td><td>Mapa de puntos encontrados. </td></tr>
    <tr><td class="paramname">th</td><td>Umbral, radio patrón para el macheo circular. El radio computado en píxeles varía para cada punto singular según el nivel de la pirámide. </td></tr>
    <tr><td class="paramname">ORBdist</td><td>Distancia máxima aceptada entre descriptores. Si el mejor macheo tiene distancia mayor, se descarta.</td></tr>
  </table>
  </dd>
</dl>
<p>Invocado exclusivamente desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html#acd4ea9e7097bed16428a4b78fe4b6a67" title="Dispara una relocalización. ">Tracking::Relocalization</a>. </p>

</div>
</div>
<a id="ac1c0dcdeed922c9a96760aa9a76a2fdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::ORBmatcher::SearchByProjection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>Scw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>vpPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>vpMatched</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>th</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ante una detección de bucle con varios macheos y una pose propuesta, este método aumenta la cantidad de macheos comparando contra otros puntos que deberían ser vistos desde el keyframe actual. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF</td><td>Keyframe actual, candidato a cerrar bucle. </td></tr>
    <tr><td class="paramname">Scw</td><td>Rototraslación y escala (sim3), transformación de pose propuesta para el cierre de bucle. </td></tr>
    <tr><td class="paramname">vpPoints</td><td>Puntos posiblemente observados según la pose calculada, a considerar en el cierre de bucle. </td></tr>
    <tr><td class="paramname">vpMatched</td><td>Puntos macheados en la detección de bucle. </td></tr>
    <tr><td class="paramname">th</td><td>Umbral.</td></tr>
  </table>
  </dd>
</dl>
<p>Invocado exclusivamente desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#ab4fcf814eed5b5dd2aec96454561b078" title="Procesa la lista de candidatos intentando corregir su pose. ">LoopClosing::ComputeSim3</a>. </p>

</div>
</div>
<a id="a9b9c641423a8075aa2a6f1d5bab4d211"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::ORBmatcher::SearchBySim3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>vpMatches12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>s12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>R12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>t12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>th</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compara dos keyframes candidatos al cierre de bucle y buscando aumentar los puntos macheados por aspecto. </p>
<p>Se proporcionan los keyframes, un vector de puntos observador por un keyframe y machedos en el otro por aspecto, y la transformación de similaridad que corrige la pose entre ellos.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF1</td><td>Keyframe actual. </td></tr>
    <tr><td class="paramname">pKF2</td><td>Keyframe candidato a cerrar el bucle. </td></tr>
    <tr><td class="paramname">vpMatches12</td><td>Dato y resultado. Puntos 3D vistos desde pKF2 y macheados por BoW y descriptores en pKF1. Vector alineado con los de pKF1. </td></tr>
    <tr><td class="paramname">s12</td><td>Escala de pFK1 respecto de pKF2. </td></tr>
    <tr><td class="paramname">R12</td><td>Matriz rotación de pFK1 respecto de pKF2. </td></tr>
    <tr><td class="paramname">t12</td><td>Traslación de pFK1 respecto de pKF2. </td></tr>
    <tr><td class="paramname">th</td><td>Radio en píxeles donde buscar puntos singulares para machear. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cantidad de puntos macheados y explicados por la Sim3.</dd></dl>
<p>Como resultado de la operación se modifica el argumento vpMatches, que se ve aumentado con nuevos macheos encontrados.</p>
<p>Invocado sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#ab4fcf814eed5b5dd2aec96454561b078" title="Procesa la lista de candidatos intentando corregir su pose. ">LoopClosing::ComputeSim3</a>. </p>

</div>
</div>
<a id="aff9b6dde7878d59e334ed5ad2ddd04eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::ORBmatcher::SearchForInitialization </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;&#160;</td>
          <td class="paramname"><em>F1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;&#160;</td>
          <td class="paramname"><em>F2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::Point2f &gt; &amp;&#160;</td>
          <td class="paramname"><em>vbPrevMatched</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>vnMatches12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>windowSize</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macheo para inicialización. </p>
<p>Este método busca macheos en una ventana holgada, procurando una elevada cantidad de macheos que luego serán considerados para la triangulación de los primeros puntos del mapa. El método se invoca de manera repetida y sucesiva, cuadro por cuadro, hasta que se logra inicializar, o hasta que la cantidad de macheo se reduce demasiado. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F1</td><td>Cuadro inicial del proceso de inicialización del mapa. </td></tr>
    <tr><td class="paramname">F2</td><td>Cuadro actual. </td></tr>
    <tr><td class="paramname">vbPrevMatched</td><td>Coordenadas de los puntos singulares macheados en el cuadro anterior (es decir, la última vez que se invocó este método). </td></tr>
    <tr><td class="paramname">vnMatches12</td><td></td></tr>
    <tr><td class="paramname">windowSize</td><td>Tamaño del área de búsqueda, windowSize es la longitud del lado del área cuadrada. Siempre es 100. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cantidad de macheos obtenidos.</dd></dl>
<p>Invocado sólo por <a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html#a7e81c68bb6ced27fcbfa2edec38ef6e0" title="Incovado por el autómata Track() para intentar inicializar. ">Tracking::MonocularInitialization</a>. </p>

</div>
</div>
<a id="a3feb387bd622e78dc8f596f90726d1c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::ORBmatcher::SearchForTriangulation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>F12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; pair&lt; size_t, size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>vMatchedPairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Machea puntos singulares entre el keyframe actual y un vecino, con el propósito posterior de triangular nuevos puntos y agregarlos al mapa. </p>
<p>Para cada punto singular del primer keyframe, el macheo recorre la línea epipolar del segundo keyframe. Usa la matriz fundamental para aplicar geomtría epipolar, una manera de comprobar la compatibilidad geométrica del macheo. Además reduce el esfuerzo de macheo comparando por BoW antes de calcular distancias de descriptores.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF1</td><td>Keyframe actual. </td></tr>
    <tr><td class="paramname">pKF2</td><td>Keyframe vecino, anterior a pKF1. </td></tr>
    <tr><td class="paramname">F12</td><td>Matriz fundamental de pKF1 respecto de pKF2. </td></tr>
    <tr><td class="paramname">vMatchedPairs</td><td>Resultado del algoritmo, los pares macheados. Si tenía algo, lo borra. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cantidad de macheos encontrados.</dd></dl>
<p>Primero utiliza <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a3588bf0a927e8ab838c614565ee7de20" title="Vector de Features de DBoW2. ">KeyFrame::mFeatVec</a> para encontrar conjuntos de puntos singulares con el mismo BoW.</p>
<p>Luego, en estos conjuntos compara distancias por "fuerza bruta".</p>
<p>Finalmente realiza una verificación epipolar.</p>
<p>Invocado sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_local_mapping.html#ac06b513357429d9eff89e29d2ae58d6c" title="El ciclo de mapeo local invoca periódicamente este método, que busca macheos candidatos para su trian...">LocalMapping::CreateNewMapPoints</a> </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa2f2d9094b4f31db4f65c93778f71494"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int ORB_SLAM2::ORBmatcher::HISTO_LENGTH = 30</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tamaño del array de histograma. </p>

</div>
</div>
<a id="a996a27217749aa15d2210c6dc6228495"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ORB_SLAM2::ORBmatcher::mbCheckOrientation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Señal interna de configuración definida en la construcción del objeto, que indica si se debe chequear la orientación antes de comparar descriptores. </p>
<p>La orientación dice de qué lado es visible el descriptor, de modo que con esta verificación se evita comparar los puntos 3D observados desde el lado contrario. Es <code>true</code> por defecto. </p>

</div>
</div>
<a id="a08f6ee66568fa5a79600ed5ad8443893"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ORB_SLAM2::ORBmatcher::mfNNratio</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nearest neighbor ratio. </p>
<p>Al buscar los dos mejores distancias, se procura que la mejor sea mayor a un porcentaje (mfNNratio) de la segunda. <code>bestDist1&lt;mfNNratio*bestDist2</code> Es 0.6 por defecto. </p>

</div>
</div>
<a id="aeb28265794388e19763e9a3dabd51473"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int ORB_SLAM2::ORBmatcher::TH_HIGH = 100</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Umbral alto, laxo, para distancias entre descriptores. </p>
<p><code>bestDist&lt;=TH_HI</code> es la chequeo habitual para aceptar o rechazar la mejor distancia luego de comparar varios descriptores candidatos. Este umbral se usa sólo dentro del objeto en ComputeSim3 y SearchByProjection para tracking. TH_HIGH se define en 100 (hasta 100 de los 256 bits del descriptor pueden ser diferentes del descriptor de referencia). </p>

</div>
</div>
<a id="a810252607722e100efe4c4e941ae00a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int ORB_SLAM2::ORBmatcher::TH_LOW = 50</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Umbral bajo, estricto, para distancias entre descriptores. </p>
<p><code>bestDist&lt;=TH_LOW</code> es la chequeo habitual para aceptar o rechazar la mejor distancia luego de comparar varios descriptores candidatos. Este umbral se usa sólo dentro del objeto, para todas los macheos excepto para machear descriptores de cuadros con descriptores de mapa. TH_LOW se define en 50 (hasta 50 de los 256 bits del descriptor pueden ser diferentes del descriptor de referencia). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/alejandro/Desarrollo eclipse/os1/include/<a class="el" href="_o_r_bmatcher_8h_source.html">ORBmatcher.h</a></li>
<li>/home/alejandro/Desarrollo eclipse/os1/src/<a class="el" href="_o_r_bmatcher_8cc.html">ORBmatcher.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_o_r_b___s_l_a_m2.html">ORB_SLAM2</a></li><li class="navelem"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bmatcher.html">ORBmatcher</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
