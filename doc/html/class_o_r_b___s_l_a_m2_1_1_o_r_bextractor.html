<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Os1: ORB_SLAM2::ORBextractor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Os1
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">OrbSlam2 documentado y modificado</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,'Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ORB_SLAM2::ORBextractor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Empaqueta todos los métodos de detección de puntos singulares y extracción de descriptores.  
 <a href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_o_r_bextractor_8h_source.html">ORBextractor.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5f326a8b3ba190c121dcdeea1d287f69"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a5f326a8b3ba190c121dcdeea1d287f69a0f496d253d29ce9b88ab80575b311b56">HARRIS_SCORE</a> =0, 
<a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a5f326a8b3ba190c121dcdeea1d287f69a504fff69083dc0081dbb34ac5d9c00b3">FAST_SCORE</a> =1
 }</td></tr>
<tr class="separator:a5f326a8b3ba190c121dcdeea1d287f69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa56b36e338372ec7cba3945c9194da4a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#aa56b36e338372ec7cba3945c9194da4a">GetInverseScaleFactors</a> ()</td></tr>
<tr class="memdesc:aa56b36e338372ec7cba3945c9194da4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el atributo protegido mvInvScaleFactor.  <a href="#aa56b36e338372ec7cba3945c9194da4a">More...</a><br /></td></tr>
<tr class="separator:aa56b36e338372ec7cba3945c9194da4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddabdd67709d7df17000cc2966c47c7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a1ddabdd67709d7df17000cc2966c47c7">GetInverseScaleSigmaSquares</a> ()</td></tr>
<tr class="memdesc:a1ddabdd67709d7df17000cc2966c47c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el atributo protegido mvInvLevelSigma2.  <a href="#a1ddabdd67709d7df17000cc2966c47c7">More...</a><br /></td></tr>
<tr class="separator:a1ddabdd67709d7df17000cc2966c47c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaad86a9c65eed8a2f8af9604b1a53ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#abaad86a9c65eed8a2f8af9604b1a53ee">GetLevels</a> ()</td></tr>
<tr class="memdesc:abaad86a9c65eed8a2f8af9604b1a53ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el atributo protegido nlevels, la cantidad de niveles en la pirámide, establecida por el constructor y de sólo lectura.  <a href="#abaad86a9c65eed8a2f8af9604b1a53ee">More...</a><br /></td></tr>
<tr class="separator:abaad86a9c65eed8a2f8af9604b1a53ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3352294ae4ae250a406140d2ae6f7286"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a3352294ae4ae250a406140d2ae6f7286">GetScaleFactor</a> ()</td></tr>
<tr class="memdesc:a3352294ae4ae250a406140d2ae6f7286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el atributo protegido scaleFactor, el factor de escala entre niveles de la pirámide, establecido por el constructor y de sólo lectura.  <a href="#a3352294ae4ae250a406140d2ae6f7286">More...</a><br /></td></tr>
<tr class="separator:a3352294ae4ae250a406140d2ae6f7286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977d96ed602e3a6ff036afc2f2f213fd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a977d96ed602e3a6ff036afc2f2f213fd">GetScaleFactors</a> ()</td></tr>
<tr class="memdesc:a977d96ed602e3a6ff036afc2f2f213fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el atributo protegido mvScaleFactor.  <a href="#a977d96ed602e3a6ff036afc2f2f213fd">More...</a><br /></td></tr>
<tr class="separator:a977d96ed602e3a6ff036afc2f2f213fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f574b3b1314c5aa645135cb2f3dca3c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a8f574b3b1314c5aa645135cb2f3dca3c">GetScaleSigmaSquares</a> ()</td></tr>
<tr class="memdesc:a8f574b3b1314c5aa645135cb2f3dca3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el atributo protegido mvLevelSigma2.  <a href="#a8f574b3b1314c5aa645135cb2f3dca3c">More...</a><br /></td></tr>
<tr class="separator:a8f574b3b1314c5aa645135cb2f3dca3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05117a839e4261638b0413fff2dc9e1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a05117a839e4261638b0413fff2dc9e1b">operator()</a> (cv::InputArray image, cv::InputArray mask, std::vector&lt; cv::KeyPoint &gt; &amp;keypoints, cv::OutputArray descriptors)</td></tr>
<tr class="memdesc:a05117a839e4261638b0413fff2dc9e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html" title="Empaqueta todos los métodos de detección de puntos singulares y extracción de descriptores. ">ORBextractor</a>(...) procesa imágenes con el operador ():  <a href="#a05117a839e4261638b0413fff2dc9e1b">More...</a><br /></td></tr>
<tr class="separator:a05117a839e4261638b0413fff2dc9e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8e010415e516246e171b9bbb9f84af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#aaa8e010415e516246e171b9bbb9f84af">ORBextractor</a> (int <a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#ab74b569810b3d3288c642cc48fd65c4c">nfeatures</a>, float <a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a13b9c3883b3fb19cb756f841cb948908">scaleFactor</a>, int <a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#aaf5c435dfb3fb2220c3847cd5f536e2f">nlevels</a>, int <a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a8997b404b50b563ffd2aea6b8130dd2a">iniThFAST</a>, int <a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a72fcac0df56c0bfe430475082df56823">minThFAST</a>)</td></tr>
<tr class="memdesc:aaa8e010415e516246e171b9bbb9f84af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor que carga los valores de configuración recibidos como argumentos, computa pirámide y precalcula factores.  <a href="#aaa8e010415e516246e171b9bbb9f84af">More...</a><br /></td></tr>
<tr class="separator:aaa8e010415e516246e171b9bbb9f84af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e5801da8f6dee0261aef5cf19e73b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#ab0e5801da8f6dee0261aef5cf19e73b3">~ORBextractor</a> ()</td></tr>
<tr class="separator:ab0e5801da8f6dee0261aef5cf19e73b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a57f88e0959582dde9ae5bdee1fe3de65"><td class="memItemLeft" align="right" valign="top">std::vector&lt; cv::Mat &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a57f88e0959582dde9ae5bdee1fe3de65">mvImagePyramid</a></td></tr>
<tr class="memdesc:a57f88e0959582dde9ae5bdee1fe3de65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imágenes de la pirámide, a las que se aplica FAST.  <a href="#a57f88e0959582dde9ae5bdee1fe3de65">More...</a><br /></td></tr>
<tr class="separator:a57f88e0959582dde9ae5bdee1fe3de65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9a543d9b2aec1e521058ee9522937adc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a9a543d9b2aec1e521058ee9522937adc">ComputeKeyPointsOctTree</a> (std::vector&lt; std::vector&lt; cv::KeyPoint &gt; &gt; &amp;allKeypoints)</td></tr>
<tr class="memdesc:a9a543d9b2aec1e521058ee9522937adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detecta puntos singulares, y los dispersa con <a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#ac6b7b27447324af33fa60d6dc0c8ffa0" title="Distribuye puntos singulares con un octTree. ">ORBextractor::DistributeOctTree</a>.  <a href="#a9a543d9b2aec1e521058ee9522937adc">More...</a><br /></td></tr>
<tr class="separator:a9a543d9b2aec1e521058ee9522937adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058f24d80bb0b2c7d6fc0bdd3d9144d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a058f24d80bb0b2c7d6fc0bdd3d9144d1">ComputePyramid</a> (cv::Mat image)</td></tr>
<tr class="memdesc:a058f24d80bb0b2c7d6fc0bdd3d9144d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Genera las imágenes de la pirámide y las guarda en el vector mvImagePyramid.  <a href="#a058f24d80bb0b2c7d6fc0bdd3d9144d1">More...</a><br /></td></tr>
<tr class="separator:a058f24d80bb0b2c7d6fc0bdd3d9144d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b7b27447324af33fa60d6dc0c8ffa0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; cv::KeyPoint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#ac6b7b27447324af33fa60d6dc0c8ffa0">DistributeOctTree</a> (const std::vector&lt; cv::KeyPoint &gt; &amp;vToDistributeKeys, const int &amp;minX, const int &amp;maxX, const int &amp;minY, const int &amp;maxY, const int &amp;nFeatures, const int &amp;level)</td></tr>
<tr class="memdesc:ac6b7b27447324af33fa60d6dc0c8ffa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distribuye puntos singulares con un octTree.  <a href="#ac6b7b27447324af33fa60d6dc0c8ffa0">More...</a><br /></td></tr>
<tr class="separator:ac6b7b27447324af33fa60d6dc0c8ffa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8997b404b50b563ffd2aea6b8130dd2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a8997b404b50b563ffd2aea6b8130dd2a">iniThFAST</a></td></tr>
<tr class="memdesc:a8997b404b50b563ffd2aea6b8130dd2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Umbral FAST inicial, usado para la detección de puntos singulares en todas las imágenes.  <a href="#a8997b404b50b563ffd2aea6b8130dd2a">More...</a><br /></td></tr>
<tr class="separator:a8997b404b50b563ffd2aea6b8130dd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fcac0df56c0bfe430475082df56823"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a72fcac0df56c0bfe430475082df56823">minThFAST</a></td></tr>
<tr class="memdesc:a72fcac0df56c0bfe430475082df56823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Umbral FAST mínimo, para maximizar la cantidad de puntos singulares detectados en una celda de la grilla, cuando el umbral inicial arroja pocos resultados.  <a href="#a72fcac0df56c0bfe430475082df56823">More...</a><br /></td></tr>
<tr class="separator:a72fcac0df56c0bfe430475082df56823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eef0343b411bff8681782115a279e2a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a2eef0343b411bff8681782115a279e2a">mnFeaturesPerLevel</a></td></tr>
<tr class="memdesc:a2eef0343b411bff8681782115a279e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cantidad de puntos singulares deseados por cada nivel de la pirámide.  <a href="#a2eef0343b411bff8681782115a279e2a">More...</a><br /></td></tr>
<tr class="separator:a2eef0343b411bff8681782115a279e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99de18a5fa2679ff1199f42b9090bf2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#af99de18a5fa2679ff1199f42b9090bf2">mvInvLevelSigma2</a></td></tr>
<tr class="memdesc:af99de18a5fa2679ff1199f42b9090bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inversa precalculada de mvLevelSigma2.  <a href="#af99de18a5fa2679ff1199f42b9090bf2">More...</a><br /></td></tr>
<tr class="separator:af99de18a5fa2679ff1199f42b9090bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eeb10aded635b28fc49422348dc72d0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a7eeb10aded635b28fc49422348dc72d0">mvInvScaleFactor</a></td></tr>
<tr class="memdesc:a7eeb10aded635b28fc49422348dc72d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inversa precalculada de mvScaleFactor.  <a href="#a7eeb10aded635b28fc49422348dc72d0">More...</a><br /></td></tr>
<tr class="separator:a7eeb10aded635b28fc49422348dc72d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9c99c509a4d1408013e91f452ef953"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a2f9c99c509a4d1408013e91f452ef953">mvLevelSigma2</a></td></tr>
<tr class="memdesc:a2f9c99c509a4d1408013e91f452ef953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cuadrado de mvScaleFactor.  <a href="#a2f9c99c509a4d1408013e91f452ef953">More...</a><br /></td></tr>
<tr class="separator:a2f9c99c509a4d1408013e91f452ef953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9432037b97eccc06715383d8c34965e9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a9432037b97eccc06715383d8c34965e9">mvScaleFactor</a></td></tr>
<tr class="memdesc:a9432037b97eccc06715383d8c34965e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor de escala abosluto de cada nivel de la pirámide, calculado a partir de scaleFactor.  <a href="#a9432037b97eccc06715383d8c34965e9">More...</a><br /></td></tr>
<tr class="separator:a9432037b97eccc06715383d8c34965e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74b569810b3d3288c642cc48fd65c4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#ab74b569810b3d3288c642cc48fd65c4c">nfeatures</a></td></tr>
<tr class="memdesc:ab74b569810b3d3288c642cc48fd65c4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cantidad de puntos singulares deseados en una imagen.  <a href="#ab74b569810b3d3288c642cc48fd65c4c">More...</a><br /></td></tr>
<tr class="separator:ab74b569810b3d3288c642cc48fd65c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5c435dfb3fb2220c3847cd5f536e2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#aaf5c435dfb3fb2220c3847cd5f536e2f">nlevels</a></td></tr>
<tr class="memdesc:aaf5c435dfb3fb2220c3847cd5f536e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cantidad de niveles de la pirámide.  <a href="#aaf5c435dfb3fb2220c3847cd5f536e2f">More...</a><br /></td></tr>
<tr class="separator:aaf5c435dfb3fb2220c3847cd5f536e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2e4f9495adf52773613987f09ae9d9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; cv::Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a3a2e4f9495adf52773613987f09ae9d9">pattern</a></td></tr>
<tr class="memdesc:a3a2e4f9495adf52773613987f09ae9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coordenadas BRIEF.  <a href="#a3a2e4f9495adf52773613987f09ae9d9">More...</a><br /></td></tr>
<tr class="separator:a3a2e4f9495adf52773613987f09ae9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b9c3883b3fb19cb756f841cb948908"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a13b9c3883b3fb19cb756f841cb948908">scaleFactor</a></td></tr>
<tr class="memdesc:a13b9c3883b3fb19cb756f841cb948908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor de escala entre niveles de la pirámide.  <a href="#a13b9c3883b3fb19cb756f841cb948908">More...</a><br /></td></tr>
<tr class="separator:a13b9c3883b3fb19cb756f841cb948908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c75fd715b20fbaf61fce11e03729901"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a8c75fd715b20fbaf61fce11e03729901">umax</a></td></tr>
<tr class="memdesc:a8c75fd715b20fbaf61fce11e03729901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Borde del parche circular de diámetro 31.  <a href="#a8c75fd715b20fbaf61fce11e03729901">More...</a><br /></td></tr>
<tr class="separator:a8c75fd715b20fbaf61fce11e03729901"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Empaqueta todos los métodos de detección de puntos singulares y extracción de descriptores. </p>
<p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html" title="Empaqueta todos los métodos de detección de puntos singulares y extracción de descriptores. ">ORBextractor</a> procesa imágenes con el operador ():</p><ul>
<li>detectando puntos singulares</li>
<li>computando sus orientaciones</li>
<li>extrayendo sus descriptores</li>
</ul>
<p>El objeto administra las pirámides y la grilla de celdas en la que se divide la imagen para homogeneizar la distribución de puntos singulares. <a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html" title="Objeto único que se ejecuta en su propio Trhead, y se inicia con Run(). ">Tracking</a> crea las únicas dos instancias de este objeto, de larga vida, mpORBextractorLeft y mpIniORBextractor, el primero como parte inicial del proceso de tracking en estado OK, y el segundo para inicializar.</p>
<p>Con la excepción de mvImagePyramid, todas las propiedades son protegidas, se establecen durante la construcción y no cambian.</p>
<p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a9a543d9b2aec1e521058ee9522937adc" title="Detecta puntos singulares, y los dispersa con ORBextractor::DistributeOctTree. ">ORBextractor::ComputeKeyPointsOctTree</a> contiene una buena descripción de los puntos singulares.</p>
<p>La clase usa las siguientes funciones globales exclusivas:</p>
<p><a class="el" href="namespace_o_r_b___s_l_a_m2.html#ac570dbdaae2d483745515b5022fd6820" title="Calcula la orientación de un punto singular. ">IC_Angle(const Mat&amp; image, Point2f pt,  const vector&lt;int&gt; &amp; u_max)</a> Determina el ángulo del parche circular con centro en pt, y diámetro PATH_SIZE = 31. Es el ángulo del vector que une pt con el baricentro del parche. u_max es un vector con los extremos línea por línea de la circunferencia pixelada. Devuelve el ángulo en radianes.</p>
<p><a class="el" href="namespace_o_r_b___s_l_a_m2.html#a40adb6b621d7c2dd9d2961ba88e445c8">computeOrientation(const Mat&amp; image, vector&lt;KeyPoint&gt;&amp; keypoints, const vector&lt;int&gt;&amp; umax)</a> Determina el ángulo de cada keypoints con IC_Angle. Guarda el resultado en keypoints[].angle .</p>
<p><a class="el" href="namespace_o_r_b___s_l_a_m2.html#a932693f631bfe871700d02c72e14c6cd" title="Extrae el descriptor ORB del punto singular. ">computeOrbDescriptor(const KeyPoint&amp; kpt, const Mat&amp; img, const Point* pattern, uchar* desc)</a> Extrae el descriptor ORB del punto singular. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kpt</td><td>Punto singular. Su ángulo expresa la orientación. </td></tr>
    <tr><td class="paramname">img</td><td>Imagen sobre la que se extraerá el descriptor. </td></tr>
    <tr><td class="paramname">pattern</td><td>Siempre el mismo, patrón de coordenadas para la evaluación BRIEF. </td></tr>
    <tr><td class="paramname">desc</td><td>Descriptor resultado, de 256 bits (32 bytes, 4 int). Invocado sólo desde computeDescriptors.</td></tr>
  </table>
  </dd>
</dl>
<p>static int bit_pattern_31_[256*4] Coordenadas BRIEF. Cada renglón contiene un par de coordenadas x,y cuyas intensidades se comparan para obtener un bit del descriptor binario. Hay 256 renglones para los 256 bits del BRIEF. Las coordenadas son relativas al punto singular a considerar, y a su orientación. Esto significa que estas coordenadas patrón se rototrasladan para obtener las coordenadas reales para extraer un descriptor. Los valores son enteros y varían entre -13 y 13. Quizás estén todos en un círculo de diámetro 31 denominado parche.</p>
<p>const float factorPI = (float)(CV_PI/180.f) Factor conversor de grados a radianes. Al multiplicar un ángulo en grados, se obtiene el ángulo en radianes. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a5f326a8b3ba190c121dcdeea1d287f69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5f326a8b3ba190c121dcdeea1d287f69a0f496d253d29ce9b88ab80575b311b56"></a>HARRIS_SCORE&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a id="a5f326a8b3ba190c121dcdeea1d287f69a504fff69083dc0081dbb34ac5d9c00b3"></a>FAST_SCORE&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaa8e010415e516246e171b9bbb9f84af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORB_SLAM2::ORBextractor::ORBextractor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nfeatures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nlevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iniThFAST</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minThFAST</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor que carga los valores de configuración recibidos como argumentos, computa pirámide y precalcula factores. </p>

</div>
</div>
<a id="ab0e5801da8f6dee0261aef5cf19e73b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ORB_SLAM2::ORBextractor::~ORBextractor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9a543d9b2aec1e521058ee9522937adc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::ORBextractor::ComputeKeyPointsOctTree </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; cv::KeyPoint &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>allKeypoints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detecta puntos singulares, y los dispersa con <a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#ac6b7b27447324af33fa60d6dc0c8ffa0" title="Distribuye puntos singulares con un octTree. ">ORBextractor::DistributeOctTree</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allKeypoints</td><td>Vector de vectores de puntos singulares a detectar, resultado del proceso. Un vector de puntos singulares para cada nivel de la pirámide.</td></tr>
  </table>
  </dd>
</dl>
<p>Los KeyPoints obtenidos almacenan los siguientes datos:</p><ul>
<li>pt, coordenadas del punto singular sobre la imagen.</li>
<li>angle, orientación obtenida con IC_Angle.</li>
<li>octave, nivel de la pirámide.</li>
<li>size, tamaño según el factor de escala del nivel de la pirámide.</li>
</ul>
<p>Invocado sólo desde ORBextractor::operator() </p>

</div>
</div>
<a id="a058f24d80bb0b2c7d6fc0bdd3d9144d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::ORBextractor::ComputePyramid </td>
          <td>(</td>
          <td class="paramtype">cv::Mat&#160;</td>
          <td class="paramname"><em>image</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Genera las imágenes de la pirámide y las guarda en el vector mvImagePyramid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Imagen a procesar, obtenida de la cámara.</td></tr>
  </table>
  </dd>
</dl>
<p>Invocado sólo desde el constructor. </p>

</div>
</div>
<a id="ac6b7b27447324af33fa60d6dc0c8ffa0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; cv::KeyPoint &gt; ORB_SLAM2::ORBextractor::DistributeOctTree </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; cv::KeyPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>vToDistributeKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>minX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>maxX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>minY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>maxY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>nFeatures</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distribuye puntos singulares con un octTree. </p>
<p>Recibe una cantidad de puntos singulaes mucho mayor a la deseada, este método elimina la mayoría de manera que los puntos sobrevivientes se encuentren dispersos en la imagen de manera homogénea. OcTree es un árbol cuyos nodos tienen 8 hijos exactamente, que de manera abstracta representan 8 vértices de un cubo. <a href="https://es.wikipedia.org/wiki/Octree">https://es.wikipedia.org/wiki/Octree</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vToDistributeKeys</td><td>Puntos singulares a distribuir. </td></tr>
    <tr><td class="paramname">minX</td><td>Borde, umbral, franja de la imagen que no se analiza. </td></tr>
    <tr><td class="paramname">maxX</td><td>Borde, umbral, franja de la imagen que no se analiza. </td></tr>
    <tr><td class="paramname">minY</td><td>Borde, umbral, franja de la imagen que no se analiza. </td></tr>
    <tr><td class="paramname">maxY</td><td>Borde, umbral, franja de la imagen que no se analiza. </td></tr>
    <tr><td class="paramname">nFeatures</td><td>Cantidad deseada de puntos singulaes. </td></tr>
    <tr><td class="paramname">level</td><td>Nivel de la pirámide a procesar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Puntos singulares distribuídos.</dd></dl>
<p>Invocado sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html#a9a543d9b2aec1e521058ee9522937adc" title="Detecta puntos singulares, y los dispersa con ORBextractor::DistributeOctTree. ">ORBextractor::ComputeKeyPointsOctTree</a> . </p>

</div>
</div>
<a id="aa56b36e338372ec7cba3945c9194da4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; ORB_SLAM2::ORBextractor::GetInverseScaleFactors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve el atributo protegido mvInvScaleFactor. </p>
<p>Invocado sólo desde el constructor de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html" title="Frame representa un cuadro, una imagen, con los puntos singulares detectados. ">Frame</a>. </p>

</div>
</div>
<a id="a1ddabdd67709d7df17000cc2966c47c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; ORB_SLAM2::ORBextractor::GetInverseScaleSigmaSquares </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve el atributo protegido mvInvLevelSigma2. </p>
<p>Invocado sólo desde el constructor de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html" title="Frame representa un cuadro, una imagen, con los puntos singulares detectados. ">Frame</a>. </p>

</div>
</div>
<a id="abaad86a9c65eed8a2f8af9604b1a53ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::ORBextractor::GetLevels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve el atributo protegido nlevels, la cantidad de niveles en la pirámide, establecida por el constructor y de sólo lectura. </p>
<p>Invocado sólo desde el constructor de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html" title="Frame representa un cuadro, una imagen, con los puntos singulares detectados. ">Frame</a>. </p>

</div>
</div>
<a id="a3352294ae4ae250a406140d2ae6f7286"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ORB_SLAM2::ORBextractor::GetScaleFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve el atributo protegido scaleFactor, el factor de escala entre niveles de la pirámide, establecido por el constructor y de sólo lectura. </p>
<p>Invocado sólo desde el constructor de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html" title="Frame representa un cuadro, una imagen, con los puntos singulares detectados. ">Frame</a>. </p>

</div>
</div>
<a id="a977d96ed602e3a6ff036afc2f2f213fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; ORB_SLAM2::ORBextractor::GetScaleFactors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve el atributo protegido mvScaleFactor. </p>
<p>Invocado sólo desde el constructor de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html" title="Frame representa un cuadro, una imagen, con los puntos singulares detectados. ">Frame</a>. </p>

</div>
</div>
<a id="a8f574b3b1314c5aa645135cb2f3dca3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; ORB_SLAM2::ORBextractor::GetScaleSigmaSquares </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Devuelve el atributo protegido mvLevelSigma2. </p>
<p>Invocado sólo desde el constructor de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html" title="Frame representa un cuadro, una imagen, con los puntos singulares detectados. ">Frame</a>. </p>

</div>
</div>
<a id="a05117a839e4261638b0413fff2dc9e1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::ORBextractor::operator() </td>
          <td>(</td>
          <td class="paramtype">cv::InputArray&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::InputArray&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; cv::KeyPoint &gt; &amp;&#160;</td>
          <td class="paramname"><em>keypoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cv::OutputArray&#160;</td>
          <td class="paramname"><em>descriptors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html" title="Empaqueta todos los métodos de detección de puntos singulares y extracción de descriptores. ">ORBextractor</a>(...) procesa imágenes con el operador (): </p>
<ul>
<li>detectando puntos singulares</li>
<li>computando sus orientaciones</li>
<li>extrayendo sus descriptores</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>Imagen a procesar. </td></tr>
    <tr><td class="paramname">mask</td><td>Máscara. No implementada. </td></tr>
    <tr><td class="paramname">keypoints</td><td>Puntos singulares detectados como resultado de la operación. </td></tr>
    <tr><td class="paramname">descriptors</td><td>Descriptores extraídos como resultado de la operación.</td></tr>
  </table>
  </dd>
</dl>
<p>Invocado sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html#a626aef981e9fd9caff63bf93f1abf47f" title="Procede con la extracción de descriptores ORB. ">Frame::ExtractORB</a> </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8997b404b50b563ffd2aea6b8130dd2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::ORBextractor::iniThFAST</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Umbral FAST inicial, usado para la detección de puntos singulares en todas las imágenes. </p>
<p>Establecido en el archivo de configuración de ORB-SLAM2. </p>

</div>
</div>
<a id="a72fcac0df56c0bfe430475082df56823"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::ORBextractor::minThFAST</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Umbral FAST mínimo, para maximizar la cantidad de puntos singulares detectados en una celda de la grilla, cuando el umbral inicial arroja pocos resultados. </p>
<p>Establecido en el archivo de configuración de ORB-SLAM2. </p>

</div>
</div>
<a id="a2eef0343b411bff8681782115a279e2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; ORB_SLAM2::ORBextractor::mnFeaturesPerLevel</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cantidad de puntos singulares deseados por cada nivel de la pirámide. </p>
<p>Todos sus valores se calculan a partir de nfeatures. Vector de longitud nlevels. </p>

</div>
</div>
<a id="a57f88e0959582dde9ae5bdee1fe3de65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;cv::Mat&gt; ORB_SLAM2::ORBextractor::mvImagePyramid</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imágenes de la pirámide, a las que se aplica FAST. </p>
<p>Producida por ComputePyramid, es un vector de ´nlevels´ imágenes. </p>

</div>
</div>
<a id="af99de18a5fa2679ff1199f42b9090bf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; ORB_SLAM2::ORBextractor::mvInvLevelSigma2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inversa precalculada de mvLevelSigma2. </p>
<p>El vector se escribe solamente en el constructor. </p>

</div>
</div>
<a id="a7eeb10aded635b28fc49422348dc72d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; ORB_SLAM2::ORBextractor::mvInvScaleFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inversa precalculada de mvScaleFactor. </p>
<p>El vector se escribe solamente en el constructor. Vector de longitud nlevels. </p>

</div>
</div>
<a id="a2f9c99c509a4d1408013e91f452ef953"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; ORB_SLAM2::ORBextractor::mvLevelSigma2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cuadrado de mvScaleFactor. </p>
<p>El vector se escribe solamente en el constructor. </p>

</div>
</div>
<a id="a9432037b97eccc06715383d8c34965e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; ORB_SLAM2::ORBextractor::mvScaleFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factor de escala abosluto de cada nivel de la pirámide, calculado a partir de scaleFactor. </p>
<p>El vector se escribe solamente en el constructor. Vector de longitud nlevels. </p>

</div>
</div>
<a id="ab74b569810b3d3288c642cc48fd65c4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::ORBextractor::nfeatures</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cantidad de puntos singulares deseados en una imagen. </p>
<p>Establecido en el archivo de configuración de ORB-SLAM2. </p>

</div>
</div>
<a id="aaf5c435dfb3fb2220c3847cd5f536e2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::ORBextractor::nlevels</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cantidad de niveles de la pirámide. </p>
<p>Establecido en el archivo de configuración de ORB-SLAM2. </p>

</div>
</div>
<a id="a3a2e4f9495adf52773613987f09ae9d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;cv::Point&gt; ORB_SLAM2::ORBextractor::pattern</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Coordenadas BRIEF. </p>
<p>Cada renglón contiene un par de coordenadas x,y cuyas intensidades se comparan para obtener un bit del descriptor binario. Hay 256 renglones para los 256 bits del BRIEF. Todas las coordenadas entran en un parche circular de 31 píxeles de diámetro. Las coordenadas son relativas al punto singular a considerar, y a su orientación. Esto significa que estas coordenadas patrón se rototrasladan para obtener las coordenadas reales para extraer un descriptor. Se definen primero en ´static int bit_pattern_31_[256*4]´ </p>

</div>
</div>
<a id="a13b9c3883b3fb19cb756f841cb948908"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ORB_SLAM2::ORBextractor::scaleFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factor de escala entre niveles de la pirámide. </p>
<p>Establecido en el archivo de configuración de ORB-SLAM2. </p>

</div>
</div>
<a id="a8c75fd715b20fbaf61fce11e03729901"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; ORB_SLAM2::ORBextractor::umax</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Borde del parche circular de diámetro 31. </p>
<p>umax es un vector de ´HALF_PATCH_SIZE + 1´ elementos, con el límite de cada línea en un cuarto de circunferencia. Tiene 16 elementos para una circunferencia de 31 píxeles de diámetro, el parche dentro del cual se extrae el descriptor. Se calcula en el constructor. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/alejandro/Desarrollo eclipse/os1/include/<a class="el" href="_o_r_bextractor_8h_source.html">ORBextractor.h</a></li>
<li>/home/alejandro/Desarrollo eclipse/os1/src/<a class="el" href="_o_r_bextractor_8cc.html">ORBextractor.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_o_r_b___s_l_a_m2.html">ORB_SLAM2</a></li><li class="navelem"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_o_r_bextractor.html">ORBextractor</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
