<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Os1: ORB_SLAM2::KeyFrame Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Os1
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">OrbSlam2 documentado y modificado</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,'Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_o_r_b___s_l_a_m2_1_1_key_frame.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_o_r_b___s_l_a_m2_1_1_key_frame-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ORB_SLAM2::KeyFrame Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Cuadro clave, keyframe.  
 <a href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_key_frame_8h_source.html">KeyFrame.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ORB_SLAM2::KeyFrame:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_o_r_b___s_l_a_m2_1_1_key_frame__coll__graph.svg" width="1179" height="242"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_o_r_b___s_l_a_m2_1_1_key_frame_1_1less_pointer.html">lessPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor de comparación para ordenar un set de KeyFrame*, por su mnId.  <a href="struct_o_r_b___s_l_a_m2_1_1_key_frame_1_1less_pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2394adfb627d9cf87ed8da78f6b0d709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a2394adfb627d9cf87ed8da78f6b0d709">AddChild</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF)</td></tr>
<tr class="memdesc:a2394adfb627d9cf87ed8da78f6b0d709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Agrega un keyframe hijo al grafo de keyframes <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ac647a33b4a6d158b640c5482ed57bbfe" title="KeyFrames hijos en el grafo, que conforman el spanning tree del grado esencial. ">KeyFrame::mspChildrens</a>.  <a href="#a2394adfb627d9cf87ed8da78f6b0d709">More...</a><br /></td></tr>
<tr class="separator:a2394adfb627d9cf87ed8da78f6b0d709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d21a23485b7c104a73d6ad3cccf4e93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a8d21a23485b7c104a73d6ad3cccf4e93">AddConnection</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF, const int &amp;weight)</td></tr>
<tr class="memdesc:a8d21a23485b7c104a73d6ad3cccf4e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conecta el keyframe con otro en el grafo de covisibilidad.  <a href="#a8d21a23485b7c104a73d6ad3cccf4e93">More...</a><br /></td></tr>
<tr class="separator:a8d21a23485b7c104a73d6ad3cccf4e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca519e7486b0e6f1fd6c98d7ced920b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aca519e7486b0e6f1fd6c98d7ced920b8">AddLoopEdge</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF)</td></tr>
<tr class="memdesc:aca519e7486b0e6f1fd6c98d7ced920b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Agrega un eje al grafo de covisibilidad, a partir de una detección de bucle.  <a href="#aca519e7486b0e6f1fd6c98d7ced920b8">More...</a><br /></td></tr>
<tr class="separator:aca519e7486b0e6f1fd6c98d7ced920b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ea4f0cfa1ca411bb3382107fe69d2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a16ea4f0cfa1ca411bb3382107fe69d2d">AddMapPoint</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *pMP, const size_t &amp;idx)</td></tr>
<tr class="memdesc:a16ea4f0cfa1ca411bb3382107fe69d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Agrega un punto 3D a la lista de puntos observados.  <a href="#a16ea4f0cfa1ca411bb3382107fe69d2d">More...</a><br /></td></tr>
<tr class="separator:a16ea4f0cfa1ca411bb3382107fe69d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd4bcef13a79d08e78307cc3d77349b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a4fd4bcef13a79d08e78307cc3d77349b">buildObservations</a> ()</td></tr>
<tr class="memdesc:a4fd4bcef13a79d08e78307cc3d77349b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstruye las observaciones de los puntos observados por el keyframe.  <a href="#a4fd4bcef13a79d08e78307cc3d77349b">More...</a><br /></td></tr>
<tr class="separator:a4fd4bcef13a79d08e78307cc3d77349b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3232df2495062749da1344db3e5a487f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a3232df2495062749da1344db3e5a487f">ChangeParent</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF)</td></tr>
<tr class="memdesc:a3232df2495062749da1344db3e5a487f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cambia el padre del keyframe en el grafo.  <a href="#a3232df2495062749da1344db3e5a487f">More...</a><br /></td></tr>
<tr class="separator:a3232df2495062749da1344db3e5a487f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac376017c23823c05a6bb851ffb2fdd8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ac376017c23823c05a6bb851ffb2fdd8f">ComputeBoW</a> ()</td></tr>
<tr class="memdesc:ac376017c23823c05a6bb851ffb2fdd8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computa BoW para los descriptores del keyframe.  <a href="#ac376017c23823c05a6bb851ffb2fdd8f">More...</a><br /></td></tr>
<tr class="separator:ac376017c23823c05a6bb851ffb2fdd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c5f9ea38d377cfa70d441e184803ae"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aa4c5f9ea38d377cfa70d441e184803ae">ComputeSceneMedianDepth</a> (const int q)</td></tr>
<tr class="memdesc:aa4c5f9ea38d377cfa70d441e184803ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computa la profundidad del punto mediano de la escena.  <a href="#aa4c5f9ea38d377cfa70d441e184803ae">More...</a><br /></td></tr>
<tr class="separator:aa4c5f9ea38d377cfa70d441e184803ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdd69627fd6a204a6ef4539303b81f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aefdd69627fd6a204a6ef4539303b81f6">EraseChild</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF)</td></tr>
<tr class="memdesc:aefdd69627fd6a204a6ef4539303b81f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Borra un keyframe hijo del grafo <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ac647a33b4a6d158b640c5482ed57bbfe" title="KeyFrames hijos en el grafo, que conforman el spanning tree del grado esencial. ">KeyFrame::mspChildrens</a>.  <a href="#aefdd69627fd6a204a6ef4539303b81f6">More...</a><br /></td></tr>
<tr class="separator:aefdd69627fd6a204a6ef4539303b81f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2e676f5e594cf9330e197a2c7df378"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a0a2e676f5e594cf9330e197a2c7df378">EraseConnection</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF)</td></tr>
<tr class="memdesc:a0a2e676f5e594cf9330e197a2c7df378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elimina del grafo de covisibilidad la conexión con el keyframe dado.  <a href="#a0a2e676f5e594cf9330e197a2c7df378">More...</a><br /></td></tr>
<tr class="separator:a0a2e676f5e594cf9330e197a2c7df378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd38a2bca9f5ced2f1f7501b8046195"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a2fd38a2bca9f5ced2f1f7501b8046195">EraseMapPointMatch</a> (const size_t &amp;idx)</td></tr>
<tr class="memdesc:a2fd38a2bca9f5ced2f1f7501b8046195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reemplaza el punto del índice por NULL en el vector mvpMapPoints.  <a href="#a2fd38a2bca9f5ced2f1f7501b8046195">More...</a><br /></td></tr>
<tr class="separator:a2fd38a2bca9f5ced2f1f7501b8046195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a775e959978e6d449386882e45b8a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ab3a775e959978e6d449386882e45b8a2">EraseMapPointMatch</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *pMP)</td></tr>
<tr class="memdesc:ab3a775e959978e6d449386882e45b8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quita el punto de la lista de puntos observados por este keyfame.  <a href="#ab3a775e959978e6d449386882e45b8a2">More...</a><br /></td></tr>
<tr class="separator:ab3a775e959978e6d449386882e45b8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecb2df01af804fb727c93948a28475f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a2ecb2df01af804fb727c93948a28475f">GetBestCovisibilityKeyFrames</a> (const int &amp;<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ac9b6948404d0ade2779335708cd443b9">N</a>)</td></tr>
<tr class="memdesc:a2ecb2df01af804fb727c93948a28475f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve los primeros y mejores N elementos del vector de keyframes covisibles <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#af4a83f5b32cf53c0ad87702226b9dff8" title="Keyframes covisibles ordenados por peso, actualizado vía KeyFrame::UpdateBestCovisibles. ">KeyFrame::mvpOrderedConnectedKeyFrames</a>.  <a href="#a2ecb2df01af804fb727c93948a28475f">More...</a><br /></td></tr>
<tr class="separator:a2ecb2df01af804fb727c93948a28475f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535f0f7db34aca7c55ddadc2ad9f4a5f"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a535f0f7db34aca7c55ddadc2ad9f4a5f">GetCameraCenter</a> ()</td></tr>
<tr class="memdesc:a535f0f7db34aca7c55ddadc2ad9f4a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lee el vector centro de cámara, igual al vector traslación para monocular.  <a href="#a535f0f7db34aca7c55ddadc2ad9f4a5f">More...</a><br /></td></tr>
<tr class="separator:a535f0f7db34aca7c55ddadc2ad9f4a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618ddd51eab47bf1d84a21d2e818a787"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a618ddd51eab47bf1d84a21d2e818a787">GetChilds</a> ()</td></tr>
<tr class="memdesc:a618ddd51eab47bf1d84a21d2e818a787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve los hijos de este keyframe.  <a href="#a618ddd51eab47bf1d84a21d2e818a787">More...</a><br /></td></tr>
<tr class="separator:a618ddd51eab47bf1d84a21d2e818a787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ffdf4441477a36c42d6605c573f1cf"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#af4ffdf4441477a36c42d6605c573f1cf">GetConnectedKeyFrames</a> ()</td></tr>
<tr class="memdesc:af4ffdf4441477a36c42d6605c573f1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve un conjunto de keyframes conectados a éste por el grafo esencial.  <a href="#af4ffdf4441477a36c42d6605c573f1cf">More...</a><br /></td></tr>
<tr class="separator:af4ffdf4441477a36c42d6605c573f1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7047bffbf130b00dd0270df99874f8a1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a7047bffbf130b00dd0270df99874f8a1">GetCovisiblesByWeight</a> (const int &amp;w)</td></tr>
<tr class="memdesc:a7047bffbf130b00dd0270df99874f8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve los mejores elementos del vector de keyframes covisibles, con peso mejor al de referencia.  <a href="#a7047bffbf130b00dd0270df99874f8a1">More...</a><br /></td></tr>
<tr class="separator:a7047bffbf130b00dd0270df99874f8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa057f2902cc7910343c5d452d33cb39f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aa057f2902cc7910343c5d452d33cb39f">GetFeaturesInArea</a> (const float &amp;x, const float &amp;y, const float &amp;r) const</td></tr>
<tr class="memdesc:aa057f2902cc7910343c5d452d33cb39f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filtra puntos singulares que estén en el cuadrado de centro x,y y lado 2 r.  <a href="#aa057f2902cc7910343c5d452d33cb39f">More...</a><br /></td></tr>
<tr class="separator:aa057f2902cc7910343c5d452d33cb39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3109e85b0ab224efdc23e51b5d2c3fa"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ab3109e85b0ab224efdc23e51b5d2c3fa">GetLoopEdges</a> ()</td></tr>
<tr class="memdesc:ab3109e85b0ab224efdc23e51b5d2c3fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informa los keyframes conectados con ejes de bucle.  <a href="#ab3109e85b0ab224efdc23e51b5d2c3fa">More...</a><br /></td></tr>
<tr class="separator:ab3109e85b0ab224efdc23e51b5d2c3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85915f3e647334634d8a4d489c63ffd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ab85915f3e647334634d8a4d489c63ffd">GetMapPoint</a> (const size_t &amp;idx)</td></tr>
<tr class="memdesc:ab85915f3e647334634d8a4d489c63ffd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el punto 3D a partir del índice.  <a href="#ab85915f3e647334634d8a4d489c63ffd">More...</a><br /></td></tr>
<tr class="separator:ab85915f3e647334634d8a4d489c63ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc5f6491c32999d9f546669737547bf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aabc5f6491c32999d9f546669737547bf">GetMapPointMatches</a> ()</td></tr>
<tr class="memdesc:aabc5f6491c32999d9f546669737547bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve una copia del vector de puntos 3D.  <a href="#aabc5f6491c32999d9f546669737547bf">More...</a><br /></td></tr>
<tr class="separator:aabc5f6491c32999d9f546669737547bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cb77a8377be3fa8c85c7b5ee45e913"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a09cb77a8377be3fa8c85c7b5ee45e913">GetMapPoints</a> ()</td></tr>
<tr class="memdesc:a09cb77a8377be3fa8c85c7b5ee45e913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve los puntos 3D observados por el keyframe.  <a href="#a09cb77a8377be3fa8c85c7b5ee45e913">More...</a><br /></td></tr>
<tr class="separator:a09cb77a8377be3fa8c85c7b5ee45e913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660cfc9a6ccf87e5497356d0d98ef06f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a660cfc9a6ccf87e5497356d0d98ef06f">GetParent</a> ()</td></tr>
<tr class="memdesc:a660cfc9a6ccf87e5497356d0d98ef06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informa el keyframe padre.  <a href="#a660cfc9a6ccf87e5497356d0d98ef06f">More...</a><br /></td></tr>
<tr class="separator:a660cfc9a6ccf87e5497356d0d98ef06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b5e212c1335cf585eaf6bbc4fed85c"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a49b5e212c1335cf585eaf6bbc4fed85c">GetPose</a> ()</td></tr>
<tr class="memdesc:a49b5e212c1335cf585eaf6bbc4fed85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lee Tcw, la pose del keyframe.  <a href="#a49b5e212c1335cf585eaf6bbc4fed85c">More...</a><br /></td></tr>
<tr class="separator:a49b5e212c1335cf585eaf6bbc4fed85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03be061f5dac65d360d65c6e8a63532f"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a03be061f5dac65d360d65c6e8a63532f">GetPoseInverse</a> ()</td></tr>
<tr class="memdesc:a03be061f5dac65d360d65c6e8a63532f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lee Twc, la matriz inversa de la pose.  <a href="#a03be061f5dac65d360d65c6e8a63532f">More...</a><br /></td></tr>
<tr class="separator:a03be061f5dac65d360d65c6e8a63532f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cdfc1cebc87d949ae6e9a0202b0f1b"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a43cdfc1cebc87d949ae6e9a0202b0f1b">GetRotation</a> ()</td></tr>
<tr class="memdesc:a43cdfc1cebc87d949ae6e9a0202b0f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lee la matriz rotación 3D, obtenida de Tcw.  <a href="#a43cdfc1cebc87d949ae6e9a0202b0f1b">More...</a><br /></td></tr>
<tr class="separator:a43cdfc1cebc87d949ae6e9a0202b0f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1426dc5447170df37c31db40edef14"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a6f1426dc5447170df37c31db40edef14">GetTranslation</a> ()</td></tr>
<tr class="memdesc:a6f1426dc5447170df37c31db40edef14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lee el vector traslación, obtenido de Tcw.  <a href="#a6f1426dc5447170df37c31db40edef14">More...</a><br /></td></tr>
<tr class="separator:a6f1426dc5447170df37c31db40edef14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9315d396634f6637f70f716336777b8d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a9315d396634f6637f70f716336777b8d">GetVectorCovisibleKeyFrames</a> ()</td></tr>
<tr class="memdesc:a9315d396634f6637f70f716336777b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el vector de keyframes covisibles <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#af4a83f5b32cf53c0ad87702226b9dff8" title="Keyframes covisibles ordenados por peso, actualizado vía KeyFrame::UpdateBestCovisibles. ">KeyFrame::mvpOrderedConnectedKeyFrames</a> .  <a href="#a9315d396634f6637f70f716336777b8d">More...</a><br /></td></tr>
<tr class="separator:a9315d396634f6637f70f716336777b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10fd3aab6431face352a930961ff713"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ab10fd3aab6431face352a930961ff713">GetWeight</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF)</td></tr>
<tr class="memdesc:ab10fd3aab6431face352a930961ff713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Informa el peso de la conexión de un determinado keyframe covisible.  <a href="#ab10fd3aab6431face352a930961ff713">More...</a><br /></td></tr>
<tr class="separator:ab10fd3aab6431face352a930961ff713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2276fdbae634194e790878adebba7861"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a2276fdbae634194e790878adebba7861">hasChild</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF)</td></tr>
<tr class="memdesc:a2276fdbae634194e790878adebba7861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indica si un keyframe es hijo de éste.  <a href="#a2276fdbae634194e790878adebba7861">More...</a><br /></td></tr>
<tr class="separator:a2276fdbae634194e790878adebba7861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c437e42b4894a4acc9f05af61e9963"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a95c437e42b4894a4acc9f05af61e9963">isBad</a> ()</td></tr>
<tr class="memdesc:a95c437e42b4894a4acc9f05af61e9963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consulta la marca mbBad.  <a href="#a95c437e42b4894a4acc9f05af61e9963">More...</a><br /></td></tr>
<tr class="separator:a95c437e42b4894a4acc9f05af61e9963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3be661e9ce7fb1809bb39a5e6fde7fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ab3be661e9ce7fb1809bb39a5e6fde7fd">IsInImage</a> (const float &amp;x, const float &amp;y) const</td></tr>
<tr class="memdesc:ab3be661e9ce7fb1809bb39a5e6fde7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifica si la coordenada está dentro del área de la imagen.  <a href="#ab3be661e9ce7fb1809bb39a5e6fde7fd">More...</a><br /></td></tr>
<tr class="separator:ab3be661e9ce7fb1809bb39a5e6fde7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2fd06ed5e4a8f9546c515db554bcb6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a6b2fd06ed5e4a8f9546c515db554bcb6">KeyFrame</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;F, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html">Map</a> *pMap, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame_database.html">KeyFrameDatabase</a> *pKFDB)</td></tr>
<tr class="memdesc:a6b2fd06ed5e4a8f9546c515db554bcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor que copia los datos del frame que se convierte en keyframe.  <a href="#a6b2fd06ed5e4a8f9546c515db554bcb6">More...</a><br /></td></tr>
<tr class="separator:a6b2fd06ed5e4a8f9546c515db554bcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35779a4eb4f5cec346780bbbdf377298"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a35779a4eb4f5cec346780bbbdf377298">ReplaceMapPointMatch</a> (const size_t &amp;idx, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *pMP)</td></tr>
<tr class="memdesc:a35779a4eb4f5cec346780bbbdf377298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reemplaza un elemento de los puntos observador por un nuevo punto 3D.  <a href="#a35779a4eb4f5cec346780bbbdf377298">More...</a><br /></td></tr>
<tr class="separator:a35779a4eb4f5cec346780bbbdf377298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338bacd1855d45c7a1cc38b9ba47a46e"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a338bacd1855d45c7a1cc38b9ba47a46e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a338bacd1855d45c7a1cc38b9ba47a46e">serialize</a> (Archive &amp;ar, const unsigned int version)</td></tr>
<tr class="separator:a338bacd1855d45c7a1cc38b9ba47a46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365ec4d06acbbcd668aa5a069c69fdaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a365ec4d06acbbcd668aa5a069c69fdaa">SetBadFlag</a> ()</td></tr>
<tr class="memdesc:a365ec4d06acbbcd668aa5a069c69fdaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intenta eliminar el keyframe y marcarlo como malo.  <a href="#a365ec4d06acbbcd668aa5a069c69fdaa">More...</a><br /></td></tr>
<tr class="separator:a365ec4d06acbbcd668aa5a069c69fdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9424cf54c979bc87df12b48e3827e834"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a9424cf54c979bc87df12b48e3827e834">SetErase</a> ()</td></tr>
<tr class="memdesc:a9424cf54c979bc87df12b48e3827e834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Libera el keyframe previamente marcado con <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aa64c7adb5f80f260cb7e997f68881b09" title="Previene la eliminación del keyframe mientras se utiliza en una detección de bucle. ">KeyFrame::SetNotErase</a>.  <a href="#a9424cf54c979bc87df12b48e3827e834">More...</a><br /></td></tr>
<tr class="separator:a9424cf54c979bc87df12b48e3827e834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64c7adb5f80f260cb7e997f68881b09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aa64c7adb5f80f260cb7e997f68881b09">SetNotErase</a> ()</td></tr>
<tr class="memdesc:aa64c7adb5f80f260cb7e997f68881b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Previene la eliminación del keyframe mientras se utiliza en una detección de bucle.  <a href="#aa64c7adb5f80f260cb7e997f68881b09">More...</a><br /></td></tr>
<tr class="separator:aa64c7adb5f80f260cb7e997f68881b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa799150fa33f3b9a404226454b96c95a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aa799150fa33f3b9a404226454b96c95a">SetPose</a> (const cv::Mat &amp;<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a8dc31ef9a08d34ecb196f3e58a2c09b9">Tcw</a>)</td></tr>
<tr class="memdesc:aa799150fa33f3b9a404226454b96c95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establece Tcw, la pose del keyframe.  <a href="#aa799150fa33f3b9a404226454b96c95a">More...</a><br /></td></tr>
<tr class="separator:aa799150fa33f3b9a404226454b96c95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729cbf2c84db5cbfdda98a9612f8cd0b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a729cbf2c84db5cbfdda98a9612f8cd0b">TrackedMapPoints</a> (const int &amp;minObs)</td></tr>
<tr class="memdesc:a729cbf2c84db5cbfdda98a9612f8cd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indica la cantidad de puntos 3D que tengan como mínimo una cantidad dada de observaciones.  <a href="#a729cbf2c84db5cbfdda98a9612f8cd0b">More...</a><br /></td></tr>
<tr class="separator:a729cbf2c84db5cbfdda98a9612f8cd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cb8502509c136536bf8d45793f8872"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a09cb8502509c136536bf8d45793f8872">UpdateBestCovisibles</a> ()</td></tr>
<tr class="memdesc:a09cb8502509c136536bf8d45793f8872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actualiza los mejores covisibles.  <a href="#a09cb8502509c136536bf8d45793f8872">More...</a><br /></td></tr>
<tr class="separator:a09cb8502509c136536bf8d45793f8872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7026956c91d4e0a01812be9dc7e8d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#afe7026956c91d4e0a01812be9dc7e8d5">UpdateConnections</a> ()</td></tr>
<tr class="memdesc:afe7026956c91d4e0a01812be9dc7e8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releva la covisibilidad y crea las conexiones en el grafo de covisibilidad.  <a href="#afe7026956c91d4e0a01812be9dc7e8d5">More...</a><br /></td></tr>
<tr class="separator:afe7026956c91d4e0a01812be9dc7e8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a921334deb73b3103f5a78322eab9bc99"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a921334deb73b3103f5a78322eab9bc99">lId</a> (<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF1, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *pKF2)</td></tr>
<tr class="memdesc:a921334deb73b3103f5a78322eab9bc99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compara Id.  <a href="#a921334deb73b3103f5a78322eab9bc99">More...</a><br /></td></tr>
<tr class="separator:a921334deb73b3103f5a78322eab9bc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d0287d1ca4a91cd9d684754c84a08b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ad2d0287d1ca4a91cd9d684754c84a08b">weightComp</a> (int a, int b)</td></tr>
<tr class="memdesc:ad2d0287d1ca4a91cd9d684754c84a08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compara dos pesos.  <a href="#ad2d0287d1ca4a91cd9d684754c84a08b">More...</a><br /></td></tr>
<tr class="separator:ad2d0287d1ca4a91cd9d684754c84a08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a44b4e47236003fc55a655092b28b18f3"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="namespace_d_bo_w2.html#a55fcd7333e591a38e96b91f41bc182f6">DBoW2::WordValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a44b4e47236003fc55a655092b28b18f3">bowPesos</a></td></tr>
<tr class="memdesc:a44b4e47236003fc55a655092b28b18f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector alineado de pesos de BoW.  <a href="#a44b4e47236003fc55a655092b28b18f3">More...</a><br /></td></tr>
<tr class="separator:a44b4e47236003fc55a655092b28b18f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf26de59fea866af8efad6006250c40c"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="namespace_d_bo_w2.html#ab1a0d3283b2d4690a383372ed20bfeb5">DBoW2::WordId</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aaf26de59fea866af8efad6006250c40c">bows</a></td></tr>
<tr class="memdesc:aaf26de59fea866af8efad6006250c40c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector alineado de BoW.  <a href="#aaf26de59fea866af8efad6006250c40c">More...</a><br /></td></tr>
<tr class="separator:aaf26de59fea866af8efad6006250c40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70011d4f3a151dd374c684e258aab4a8"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a70011d4f3a151dd374c684e258aab4a8">cx</a></td></tr>
<tr class="separator:a70011d4f3a151dd374c684e258aab4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78735c57b92b2d5960ed21c97dfe6a8"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ae78735c57b92b2d5960ed21c97dfe6a8">cy</a></td></tr>
<tr class="separator:ae78735c57b92b2d5960ed21c97dfe6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951e9ac5670b8543a7386dee5714da0c"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a951e9ac5670b8543a7386dee5714da0c">fx</a></td></tr>
<tr class="memdesc:a951e9ac5670b8543a7386dee5714da0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parámetros de calibración.  <a href="#a951e9ac5670b8543a7386dee5714da0c">More...</a><br /></td></tr>
<tr class="separator:a951e9ac5670b8543a7386dee5714da0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1acd1b8dad098299d350f67dc4517c0"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ab1acd1b8dad098299d350f67dc4517c0">fy</a></td></tr>
<tr class="separator:ab1acd1b8dad098299d350f67dc4517c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ce06c4d206f7ddb1daeeb7c43eb074"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a00ce06c4d206f7ddb1daeeb7c43eb074">invfx</a></td></tr>
<tr class="separator:a00ce06c4d206f7ddb1daeeb7c43eb074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b96f772fad3b9b816dae9f8a719a15d"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a7b96f772fad3b9b816dae9f8a719a15d">invfy</a></td></tr>
<tr class="separator:a7b96f772fad3b9b816dae9f8a719a15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cb0dee48e804c5b1f30afd0ce99787"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_d_bo_w2_1_1_bow_vector.html">DBoW2::BowVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a70cb0dee48e804c5b1f30afd0ce99787">mBowVec</a></td></tr>
<tr class="memdesc:a70cb0dee48e804c5b1f30afd0ce99787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector de BoW obtenidos de los descriptores del keyframe.  <a href="#a70cb0dee48e804c5b1f30afd0ce99787">More...</a><br /></td></tr>
<tr class="separator:a70cb0dee48e804c5b1f30afd0ce99787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08ac0ce59e2c003c182f946de3b3bc0"><td class="memItemLeft" align="right" valign="top">const cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ae08ac0ce59e2c003c182f946de3b3bc0">mDescriptors</a></td></tr>
<tr class="memdesc:ae08ac0ce59e2c003c182f946de3b3bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Descriptores.  <a href="#ae08ac0ce59e2c003c182f946de3b3bc0">More...</a><br /></td></tr>
<tr class="separator:ae08ac0ce59e2c003c182f946de3b3bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3588bf0a927e8ab838c614565ee7de20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_d_bo_w2_1_1_feature_vector.html">DBoW2::FeatureVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a3588bf0a927e8ab838c614565ee7de20">mFeatVec</a></td></tr>
<tr class="memdesc:a3588bf0a927e8ab838c614565ee7de20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector de Features de <a class="el" href="namespace_d_bo_w2.html" title="File: BowVector.cpp Date: March 2011 Author: Dorian Galvez-Lopez Description: bag of words vector Lic...">DBoW2</a>.  <a href="#a3588bf0a927e8ab838c614565ee7de20">More...</a><br /></td></tr>
<tr class="separator:a3588bf0a927e8ab838c614565ee7de20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89412cd7a6d467c262a7c3a584c81990"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a89412cd7a6d467c262a7c3a584c81990">mfGridElementHeightInv</a></td></tr>
<tr class="memdesc:a89412cd7a6d467c262a7c3a584c81990"><td class="mdescLeft">&#160;</td><td class="mdescRight">La inversa del alto de la grilla en píxeles.  <a href="#a89412cd7a6d467c262a7c3a584c81990">More...</a><br /></td></tr>
<tr class="separator:a89412cd7a6d467c262a7c3a584c81990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad664a3275b80e901f3fa290ad7804e"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a7ad664a3275b80e901f3fa290ad7804e">mfGridElementWidthInv</a></td></tr>
<tr class="memdesc:a7ad664a3275b80e901f3fa290ad7804e"><td class="mdescLeft">&#160;</td><td class="mdescRight">La inversa del ancho de la grilla en píxeles.  <a href="#a7ad664a3275b80e901f3fa290ad7804e">More...</a><br /></td></tr>
<tr class="separator:a7ad664a3275b80e901f3fa290ad7804e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ca053915d4aaba66c1fd5962182d14"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ae7ca053915d4aaba66c1fd5962182d14">mfLogScaleFactor</a></td></tr>
<tr class="memdesc:ae7ca053915d4aaba66c1fd5962182d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logaritmo del factor de escala.  <a href="#ae7ca053915d4aaba66c1fd5962182d14">More...</a><br /></td></tr>
<tr class="separator:ae7ca053915d4aaba66c1fd5962182d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fbd1aa1da7c7cd68cb05d8e5b78a08"><td class="memItemLeft" align="right" valign="top">const float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a18fbd1aa1da7c7cd68cb05d8e5b78a08">mfScaleFactor</a></td></tr>
<tr class="memdesc:a18fbd1aa1da7c7cd68cb05d8e5b78a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor de escala entre dos niveles consecutivos de la pirámide.  <a href="#a18fbd1aa1da7c7cd68cb05d8e5b78a08">More...</a><br /></td></tr>
<tr class="separator:a18fbd1aa1da7c7cd68cb05d8e5b78a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb8246d60511b756ba241de680e96ac"><td class="memItemLeft" align="right" valign="top">const cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#afcb8246d60511b756ba241de680e96ac">mK</a></td></tr>
<tr class="memdesc:afcb8246d60511b756ba241de680e96ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matriz K de calibración de cámara.  <a href="#afcb8246d60511b756ba241de680e96ac">More...</a><br /></td></tr>
<tr class="separator:afcb8246d60511b756ba241de680e96ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40712f54ab899a6dbd795405a4984ab5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a40712f54ab899a6dbd795405a4984ab5">mLoopScore</a></td></tr>
<tr class="memdesc:a40712f54ab899a6dbd795405a4984ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable efímera usadas por la base de datos de keyframes.  <a href="#a40712f54ab899a6dbd795405a4984ab5">More...</a><br /></td></tr>
<tr class="separator:a40712f54ab899a6dbd795405a4984ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484457e131f76713de4dc4e0bc9b5fed"><td class="memItemLeft" align="right" valign="top">long unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a484457e131f76713de4dc4e0bc9b5fed">mnBAFixedForKF</a></td></tr>
<tr class="memdesc:a484457e131f76713de4dc4e0bc9b5fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable efímera usadas por el mapeo local.  <a href="#a484457e131f76713de4dc4e0bc9b5fed">More...</a><br /></td></tr>
<tr class="separator:a484457e131f76713de4dc4e0bc9b5fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b686c81674d0248b5f7dabdfd58ecb"><td class="memItemLeft" align="right" valign="top">long unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a31b686c81674d0248b5f7dabdfd58ecb">mnBAGlobalForKF</a></td></tr>
<tr class="memdesc:a31b686c81674d0248b5f7dabdfd58ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable efímera usadas por cierre de bucle.  <a href="#a31b686c81674d0248b5f7dabdfd58ecb">More...</a><br /></td></tr>
<tr class="separator:a31b686c81674d0248b5f7dabdfd58ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75767b3e2e5f8eb4b4b73cba161b097b"><td class="memItemLeft" align="right" valign="top">long unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a75767b3e2e5f8eb4b4b73cba161b097b">mnBALocalForKF</a></td></tr>
<tr class="memdesc:a75767b3e2e5f8eb4b4b73cba161b097b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable efímera usadas por el mapeo local.  <a href="#a75767b3e2e5f8eb4b4b73cba161b097b">More...</a><br /></td></tr>
<tr class="separator:a75767b3e2e5f8eb4b4b73cba161b097b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ad29c06d8c969a341d9f633b43569e"><td class="memItemLeft" align="right" valign="top">const long unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a75ad29c06d8c969a341d9f633b43569e">mnFrameId</a></td></tr>
<tr class="memdesc:a75ad29c06d8c969a341d9f633b43569e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Id del frame asociado.  <a href="#a75ad29c06d8c969a341d9f633b43569e">More...</a><br /></td></tr>
<tr class="separator:a75ad29c06d8c969a341d9f633b43569e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bad332e7057e8f59d630e78c7994129"><td class="memItemLeft" align="right" valign="top">long unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a2bad332e7057e8f59d630e78c7994129">mnFuseTargetForKF</a></td></tr>
<tr class="memdesc:a2bad332e7057e8f59d630e78c7994129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable efímera usadas por <a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html" title="Objeto único que se ejecuta en su propio Trhead, y se inicia con Run(). ">Tracking</a>.  <a href="#a2bad332e7057e8f59d630e78c7994129">More...</a><br /></td></tr>
<tr class="separator:a2bad332e7057e8f59d630e78c7994129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe0d03aabb1643abb8f4eef33fdf95a"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a7fe0d03aabb1643abb8f4eef33fdf95a">mnGridCols</a></td></tr>
<tr class="memdesc:a7fe0d03aabb1643abb8f4eef33fdf95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimensiones de la grilla del frame para acelerar macheo.  <a href="#a7fe0d03aabb1643abb8f4eef33fdf95a">More...</a><br /></td></tr>
<tr class="separator:a7fe0d03aabb1643abb8f4eef33fdf95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb859eb91a2365180b006a185aa36ba6"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#afb859eb91a2365180b006a185aa36ba6">mnGridRows</a></td></tr>
<tr class="memdesc:afb859eb91a2365180b006a185aa36ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dimensiones de la grilla del frame para acelerar macheo.  <a href="#afb859eb91a2365180b006a185aa36ba6">More...</a><br /></td></tr>
<tr class="separator:afb859eb91a2365180b006a185aa36ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3d56caca4e4cc372c36a3270d490c7"><td class="memItemLeft" align="right" valign="top">long unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a1e3d56caca4e4cc372c36a3270d490c7">mnId</a></td></tr>
<tr class="memdesc:a1e3d56caca4e4cc372c36a3270d490c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Id del keyFrame.  <a href="#a1e3d56caca4e4cc372c36a3270d490c7">More...</a><br /></td></tr>
<tr class="separator:a1e3d56caca4e4cc372c36a3270d490c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3446f5fd861f1e51faf9191c1eb75ab"><td class="memItemLeft" align="right" valign="top">long unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ae3446f5fd861f1e51faf9191c1eb75ab">mnLoopQuery</a></td></tr>
<tr class="memdesc:ae3446f5fd861f1e51faf9191c1eb75ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable efímera usadas por la base de datos de keyframes.  <a href="#ae3446f5fd861f1e51faf9191c1eb75ab">More...</a><br /></td></tr>
<tr class="separator:ae3446f5fd861f1e51faf9191c1eb75ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d7ead1b29c188be610208f11625d24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a36d7ead1b29c188be610208f11625d24">mnLoopWords</a></td></tr>
<tr class="memdesc:a36d7ead1b29c188be610208f11625d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable efímera usadas por la base de datos de keyframes.  <a href="#a36d7ead1b29c188be610208f11625d24">More...</a><br /></td></tr>
<tr class="separator:a36d7ead1b29c188be610208f11625d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677fd210bec35232bda003b543d0acfc"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a677fd210bec35232bda003b543d0acfc">mnMaxX</a></td></tr>
<tr class="memdesc:a677fd210bec35232bda003b543d0acfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vértices de la imagen antidistorsionada: mnMinX, mnMinY, mnMaxX, mnMaxY.  <a href="#a677fd210bec35232bda003b543d0acfc">More...</a><br /></td></tr>
<tr class="separator:a677fd210bec35232bda003b543d0acfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababbbd404314965b13a51e6414dce6ad"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ababbbd404314965b13a51e6414dce6ad">mnMaxY</a></td></tr>
<tr class="memdesc:ababbbd404314965b13a51e6414dce6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vértices de la imagen antidistorsionada: mnMinX, mnMinY, mnMaxX, mnMaxY.  <a href="#ababbbd404314965b13a51e6414dce6ad">More...</a><br /></td></tr>
<tr class="separator:ababbbd404314965b13a51e6414dce6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b00239e47ff44e5578c2eeaf3d3cc8"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a02b00239e47ff44e5578c2eeaf3d3cc8">mnMinX</a></td></tr>
<tr class="memdesc:a02b00239e47ff44e5578c2eeaf3d3cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vértices de la imagen antidistorsionada: mnMinX, mnMinY, mnMaxX, mnMaxY.  <a href="#a02b00239e47ff44e5578c2eeaf3d3cc8">More...</a><br /></td></tr>
<tr class="separator:a02b00239e47ff44e5578c2eeaf3d3cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96accf480c4bbc3212efb47278db8c5"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ab96accf480c4bbc3212efb47278db8c5">mnMinY</a></td></tr>
<tr class="memdesc:ab96accf480c4bbc3212efb47278db8c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vértices de la imagen antidistorsionada: mnMinX, mnMinY, mnMaxX, mnMaxY.  <a href="#ab96accf480c4bbc3212efb47278db8c5">More...</a><br /></td></tr>
<tr class="separator:ab96accf480c4bbc3212efb47278db8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028c2a2f0f737ec09719712c84339748"><td class="memItemLeft" align="right" valign="top">long unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a028c2a2f0f737ec09719712c84339748">mnRelocQuery</a></td></tr>
<tr class="memdesc:a028c2a2f0f737ec09719712c84339748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable efímera usadas por por la base de datos de keyframes.  <a href="#a028c2a2f0f737ec09719712c84339748">More...</a><br /></td></tr>
<tr class="separator:a028c2a2f0f737ec09719712c84339748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1f8023efe8ddf58ac5d1d2cf41c0cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a0b1f8023efe8ddf58ac5d1d2cf41c0cf">mnRelocWords</a></td></tr>
<tr class="memdesc:a0b1f8023efe8ddf58ac5d1d2cf41c0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable efímera usadas por la base de datos de keyframes.  <a href="#a0b1f8023efe8ddf58ac5d1d2cf41c0cf">More...</a><br /></td></tr>
<tr class="separator:a0b1f8023efe8ddf58ac5d1d2cf41c0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3b2544330774672483656955e0ca03"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#abd3b2544330774672483656955e0ca03">mnScaleLevels</a></td></tr>
<tr class="memdesc:abd3b2544330774672483656955e0ca03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pose de cámara relativa a su padre.  <a href="#abd3b2544330774672483656955e0ca03">More...</a><br /></td></tr>
<tr class="separator:abd3b2544330774672483656955e0ca03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c775159303dc3435fc05e73f30f2865"><td class="memItemLeft" align="right" valign="top">long unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a1c775159303dc3435fc05e73f30f2865">mnTrackReferenceForFrame</a></td></tr>
<tr class="memdesc:a1c775159303dc3435fc05e73f30f2865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable efímera usadas por <a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html" title="Objeto único que se ejecuta en su propio Trhead, y se inicia con Run(). ">Tracking</a>.  <a href="#a1c775159303dc3435fc05e73f30f2865">More...</a><br /></td></tr>
<tr class="separator:a1c775159303dc3435fc05e73f30f2865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f768a3601ac95f99dff3fd511f2a6e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a78f768a3601ac95f99dff3fd511f2a6e">mRelocScore</a></td></tr>
<tr class="memdesc:a78f768a3601ac95f99dff3fd511f2a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable efímera usadas por la base de datos de keyframes.  <a href="#a78f768a3601ac95f99dff3fd511f2a6e">More...</a><br /></td></tr>
<tr class="separator:a78f768a3601ac95f99dff3fd511f2a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6fb84afa3701dcc6b1e3e76ccb36fa"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a4a6fb84afa3701dcc6b1e3e76ccb36fa">mTcwBefGBA</a></td></tr>
<tr class="memdesc:a4a6fb84afa3701dcc6b1e3e76ccb36fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable usada en cierre de bucle.  <a href="#a4a6fb84afa3701dcc6b1e3e76ccb36fa">More...</a><br /></td></tr>
<tr class="separator:a4a6fb84afa3701dcc6b1e3e76ccb36fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bdd885bb078b5e1910c2317e9aa112"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ac9bdd885bb078b5e1910c2317e9aa112">mTcwGBA</a></td></tr>
<tr class="memdesc:ac9bdd885bb078b5e1910c2317e9aa112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable usada en cierre de bucle.  <a href="#ac9bdd885bb078b5e1910c2317e9aa112">More...</a><br /></td></tr>
<tr class="separator:ac9bdd885bb078b5e1910c2317e9aa112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fa3d61a524547cfe2be2523d199833"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ab4fa3d61a524547cfe2be2523d199833">mTimeStamp</a></td></tr>
<tr class="memdesc:ab4fa3d61a524547cfe2be2523d199833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time stamp.  <a href="#ab4fa3d61a524547cfe2be2523d199833">More...</a><br /></td></tr>
<tr class="separator:ab4fa3d61a524547cfe2be2523d199833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320d543b9585072c264b4e6f7e334bad"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a320d543b9585072c264b4e6f7e334bad">mvInvLevelSigma2</a></td></tr>
<tr class="memdesc:a320d543b9585072c264b4e6f7e334bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inversa de sigma cuadrado para cada nivel de la pirámide.  <a href="#a320d543b9585072c264b4e6f7e334bad">More...</a><br /></td></tr>
<tr class="separator:a320d543b9585072c264b4e6f7e334bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bcd5810e62ec163a3f38ccb806d04a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; cv::KeyPoint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aa1bcd5810e62ec163a3f38ccb806d04a">mvKeys</a></td></tr>
<tr class="memdesc:aa1bcd5810e62ec163a3f38ccb806d04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puntos singulares visualizados por el keyframe.  <a href="#aa1bcd5810e62ec163a3f38ccb806d04a">More...</a><br /></td></tr>
<tr class="separator:aa1bcd5810e62ec163a3f38ccb806d04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6c65fc098f41ff418a65934f514ce3"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; cv::KeyPoint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aaf6c65fc098f41ff418a65934f514ce3">mvKeysUn</a></td></tr>
<tr class="memdesc:aaf6c65fc098f41ff418a65934f514ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puntos singulares con coordenadas "antidistorsionadas".  <a href="#aaf6c65fc098f41ff418a65934f514ce3">More...</a><br /></td></tr>
<tr class="separator:aaf6c65fc098f41ff418a65934f514ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a9029bf7ea62953ac38644756fcd3b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aa4a9029bf7ea62953ac38644756fcd3b">mvLevelSigma2</a></td></tr>
<tr class="memdesc:aa4a9029bf7ea62953ac38644756fcd3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sigma cuadrado (cuadrado de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a8cdc02a7bccd3b75e61351a1f14f9c04" title="Factores de escala absolutos para cada nivel de la pirámide. ">KeyFrame::mvScaleFactors</a>) para cada nivel de la pirámide.  <a href="#aa4a9029bf7ea62953ac38644756fcd3b">More...</a><br /></td></tr>
<tr class="separator:aa4a9029bf7ea62953ac38644756fcd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdc02a7bccd3b75e61351a1f14f9c04"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a8cdc02a7bccd3b75e61351a1f14f9c04">mvScaleFactors</a></td></tr>
<tr class="memdesc:a8cdc02a7bccd3b75e61351a1f14f9c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factores de escala absolutos para cada nivel de la pirámide.  <a href="#a8cdc02a7bccd3b75e61351a1f14f9c04">More...</a><br /></td></tr>
<tr class="separator:a8cdc02a7bccd3b75e61351a1f14f9c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b6948404d0ade2779335708cd443b9"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ac9b6948404d0ade2779335708cd443b9">N</a></td></tr>
<tr class="memdesc:ac9b6948404d0ade2779335708cd443b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cantidad de puntos singulares.  <a href="#ac9b6948404d0ade2779335708cd443b9">More...</a><br /></td></tr>
<tr class="separator:ac9b6948404d0ade2779335708cd443b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71410c456b6354264ce0369883d96459"><td class="memItemLeft" align="right" valign="top">vector&lt; cv::Vec3b &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a71410c456b6354264ce0369883d96459">vRgb</a></td></tr>
<tr class="memdesc:a71410c456b6354264ce0369883d96459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color de los keypoints.  <a href="#a71410c456b6354264ce0369883d96459">More...</a><br /></td></tr>
<tr class="separator:a71410c456b6354264ce0369883d96459"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:acb0d220936541a8afc020a65aa675559"><td class="memItemLeft" align="right" valign="top">static long unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#acb0d220936541a8afc020a65aa675559">nNextId</a> =0</td></tr>
<tr class="memdesc:acb0d220936541a8afc020a65aa675559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contador para autonumeración de ids.  <a href="#acb0d220936541a8afc020a65aa675559">More...</a><br /></td></tr>
<tr class="separator:acb0d220936541a8afc020a65aa675559"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3c33a6c79533849d367db9e85fe98c14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a3c33a6c79533849d367db9e85fe98c14">KeyFrame</a> ()</td></tr>
<tr class="memdesc:a3c33a6c79533849d367db9e85fe98c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor por defecto para <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a> Se ocupa de inicializar los atributos const, para que el compilador no chille.  <a href="#a3c33a6c79533849d367db9e85fe98c14">More...</a><br /></td></tr>
<tr class="separator:a3c33a6c79533849d367db9e85fe98c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bbcbd5f862204ac10985a51d8cd74f"><td class="memTemplParams" colspan="2">template&lt;class Archivo &gt; </td></tr>
<tr class="memitem:a03bbcbd5f862204ac10985a51d8cd74f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a03bbcbd5f862204ac10985a51d8cd74f">serialize</a> (Archivo &amp;, const unsigned int)</td></tr>
<tr class="memdesc:a03bbcbd5f862204ac10985a51d8cd74f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializador para <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a>.  <a href="#a03bbcbd5f862204ac10985a51d8cd74f">More...</a><br /></td></tr>
<tr class="separator:a03bbcbd5f862204ac10985a51d8cd74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9ed66ca840fb2288ee6b700bb4fc6858"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a9ed66ca840fb2288ee6b700bb4fc6858">mbBad</a></td></tr>
<tr class="memdesc:a9ed66ca840fb2288ee6b700bb4fc6858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag de eliminación.  <a href="#a9ed66ca840fb2288ee6b700bb4fc6858">More...</a><br /></td></tr>
<tr class="separator:a9ed66ca840fb2288ee6b700bb4fc6858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad3ef1653d6cfa622994bd2c1bd67c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a9ad3ef1653d6cfa622994bd2c1bd67c1">mbFirstConnection</a></td></tr>
<tr class="memdesc:a9ad3ef1653d6cfa622994bd2c1bd67c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estado del autómata de inicialización.  <a href="#a9ad3ef1653d6cfa622994bd2c1bd67c1">More...</a><br /></td></tr>
<tr class="separator:a9ad3ef1653d6cfa622994bd2c1bd67c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf677dc6fdd14e6122d0f5e09c01850"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aecf677dc6fdd14e6122d0f5e09c01850">mbNotErase</a></td></tr>
<tr class="memdesc:aecf677dc6fdd14e6122d0f5e09c01850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Señal de no borrar.  <a href="#aecf677dc6fdd14e6122d0f5e09c01850">More...</a><br /></td></tr>
<tr class="separator:aecf677dc6fdd14e6122d0f5e09c01850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae282bb579271984c9ee0d55bac7f5dee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ae282bb579271984c9ee0d55bac7f5dee">mbToBeErased</a></td></tr>
<tr class="memdesc:ae282bb579271984c9ee0d55bac7f5dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marca el keyframe para ser borrado.  <a href="#ae282bb579271984c9ee0d55bac7f5dee">More...</a><br /></td></tr>
<tr class="separator:ae282bb579271984c9ee0d55bac7f5dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a057195e3e9e7d3f08b97b6366e9f81"><td class="memItemLeft" align="right" valign="top">std::map&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a6a057195e3e9e7d3f08b97b6366e9f81">mConnectedKeyFrameWeights</a></td></tr>
<tr class="memdesc:a6a057195e3e9e7d3f08b97b6366e9f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapa de covisibilidad, que vincula los keyframes covisibles con sus pesos.  <a href="#a6a057195e3e9e7d3f08b97b6366e9f81">More...</a><br /></td></tr>
<tr class="separator:a6a057195e3e9e7d3f08b97b6366e9f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01e44ecc9b907b3f85094d84de08cb8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; size_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aa01e44ecc9b907b3f85094d84de08cb8">mGrid</a></td></tr>
<tr class="separator:aa01e44ecc9b907b3f85094d84de08cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30315bba6d290ec12227cf9c0aed5df1"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a30315bba6d290ec12227cf9c0aed5df1">mMutexConnections</a></td></tr>
<tr class="memdesc:a30315bba6d290ec12227cf9c0aed5df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutex de acceso al grafo de conexiones.  <a href="#a30315bba6d290ec12227cf9c0aed5df1">More...</a><br /></td></tr>
<tr class="separator:a30315bba6d290ec12227cf9c0aed5df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb19a0cf32ad590df9794f77585e9ce8"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#acb19a0cf32ad590df9794f77585e9ce8">mMutexFeatures</a></td></tr>
<tr class="memdesc:acb19a0cf32ad590df9794f77585e9ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutex de acceso a mvpMapPoints.  <a href="#acb19a0cf32ad590df9794f77585e9ce8">More...</a><br /></td></tr>
<tr class="separator:acb19a0cf32ad590df9794f77585e9ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca0141e2657237c4b7847512585cb49"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a7ca0141e2657237c4b7847512585cb49">mMutexPose</a></td></tr>
<tr class="memdesc:a7ca0141e2657237c4b7847512585cb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutex de acceso a la pose Tcw.  <a href="#a7ca0141e2657237c4b7847512585cb49">More...</a><br /></td></tr>
<tr class="separator:a7ca0141e2657237c4b7847512585cb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0f82c40703deb82fbc593d9e17ea1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame_database.html">KeyFrameDatabase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a0d0f82c40703deb82fbc593d9e17ea1a">mpKeyFrameDB</a></td></tr>
<tr class="memdesc:a0d0f82c40703deb82fbc593d9e17ea1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base de datos de keyframes, donde se encuentra este keyframe.  <a href="#a0d0f82c40703deb82fbc593d9e17ea1a">More...</a><br /></td></tr>
<tr class="separator:a0d0f82c40703deb82fbc593d9e17ea1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fd59a0e3f3c32cf90c03a087ffd31b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html">Map</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ab1fd59a0e3f3c32cf90c03a087ffd31b">mpMap</a></td></tr>
<tr class="memdesc:ab1fd59a0e3f3c32cf90c03a087ffd31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mapa donde se encuentra el keyFrame.  <a href="#ab1fd59a0e3f3c32cf90c03a087ffd31b">More...</a><br /></td></tr>
<tr class="separator:ab1fd59a0e3f3c32cf90c03a087ffd31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab268c7bd221fb11554a9f21f56a5550a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_o_r_b___s_l_a_m2.html#a2fafba714858cab1bb18d438e2e83c5d">ORBVocabulary</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ab268c7bd221fb11554a9f21f56a5550a">mpORBvocabulary</a></td></tr>
<tr class="memdesc:ab268c7bd221fb11554a9f21f56a5550a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vocabulario BoW para ORB.  <a href="#ab268c7bd221fb11554a9f21f56a5550a">More...</a><br /></td></tr>
<tr class="separator:ab268c7bd221fb11554a9f21f56a5550a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bbb0261caf3f1ed0c434c9fca1e886"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a94bbb0261caf3f1ed0c434c9fca1e886">mpParent</a></td></tr>
<tr class="memdesc:a94bbb0261caf3f1ed0c434c9fca1e886"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a> padre en el grafo.  <a href="#a94bbb0261caf3f1ed0c434c9fca1e886">More...</a><br /></td></tr>
<tr class="separator:a94bbb0261caf3f1ed0c434c9fca1e886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac647a33b4a6d158b640c5482ed57bbfe"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ac647a33b4a6d158b640c5482ed57bbfe">mspChildrens</a></td></tr>
<tr class="memdesc:ac647a33b4a6d158b640c5482ed57bbfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">KeyFrames hijos en el grafo, que conforman el spanning tree del grado esencial.  <a href="#ac647a33b4a6d158b640c5482ed57bbfe">More...</a><br /></td></tr>
<tr class="separator:ac647a33b4a6d158b640c5482ed57bbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c0b63cb66f5ca99639c6c54aa67e1b"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a64c0b63cb66f5ca99639c6c54aa67e1b">mspLoopEdges</a></td></tr>
<tr class="memdesc:a64c0b63cb66f5ca99639c6c54aa67e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">KeyFrames que participan de un extremo de un bucle.  <a href="#a64c0b63cb66f5ca99639c6c54aa67e1b">More...</a><br /></td></tr>
<tr class="separator:a64c0b63cb66f5ca99639c6c54aa67e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac0492454556dc98bb6bd895acfec9b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aeac0492454556dc98bb6bd895acfec9b">mvOrderedWeights</a></td></tr>
<tr class="memdesc:aeac0492454556dc98bb6bd895acfec9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pesos de los keyframes de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#af4a83f5b32cf53c0ad87702226b9dff8" title="Keyframes covisibles ordenados por peso, actualizado vía KeyFrame::UpdateBestCovisibles. ">KeyFrame::mvpOrderedConnectedKeyFrames</a>.  <a href="#aeac0492454556dc98bb6bd895acfec9b">More...</a><br /></td></tr>
<tr class="separator:aeac0492454556dc98bb6bd895acfec9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777aab9cb7c1fd8e83f143e77a9f1b03"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a777aab9cb7c1fd8e83f143e77a9f1b03">mvpMapPoints</a></td></tr>
<tr class="memdesc:a777aab9cb7c1fd8e83f143e77a9f1b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puntos del mapa asociado a los puntos singulares.  <a href="#a777aab9cb7c1fd8e83f143e77a9f1b03">More...</a><br /></td></tr>
<tr class="separator:a777aab9cb7c1fd8e83f143e77a9f1b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a83f5b32cf53c0ad87702226b9dff8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#af4a83f5b32cf53c0ad87702226b9dff8">mvpOrderedConnectedKeyFrames</a></td></tr>
<tr class="memdesc:af4a83f5b32cf53c0ad87702226b9dff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keyframes covisibles ordenados por peso, actualizado vía <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a09cb8502509c136536bf8d45793f8872" title="Actualiza los mejores covisibles. ">KeyFrame::UpdateBestCovisibles</a>.  <a href="#af4a83f5b32cf53c0ad87702226b9dff8">More...</a><br /></td></tr>
<tr class="separator:af4a83f5b32cf53c0ad87702226b9dff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3044f098f2b7d25b33b180b20c5a5fa6"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a3044f098f2b7d25b33b180b20c5a5fa6">Ow</a></td></tr>
<tr class="memdesc:a3044f098f2b7d25b33b180b20c5a5fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Centro de la cámara, posición de la cámara.  <a href="#a3044f098f2b7d25b33b180b20c5a5fa6">More...</a><br /></td></tr>
<tr class="separator:a3044f098f2b7d25b33b180b20c5a5fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc31ef9a08d34ecb196f3e58a2c09b9"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a8dc31ef9a08d34ecb196f3e58a2c09b9">Tcw</a></td></tr>
<tr class="memdesc:a8dc31ef9a08d34ecb196f3e58a2c09b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matriz de 4x4 de rototraslación en coordenadas homogéneas, que expresa la pose del keyframe.  <a href="#a8dc31ef9a08d34ecb196f3e58a2c09b9">More...</a><br /></td></tr>
<tr class="separator:a8dc31ef9a08d34ecb196f3e58a2c09b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769de03e37e9531ab43625250287ff8c"><td class="memItemLeft" align="right" valign="top">cv::Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a769de03e37e9531ab43625250287ff8c">Twc</a></td></tr>
<tr class="memdesc:a769de03e37e9531ab43625250287ff8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matriz de 4x4 de rototraslación en coordenadas homogéneas, con la transformación inversa de Tcw.  <a href="#a769de03e37e9531ab43625250287ff8c">More...</a><br /></td></tr>
<tr class="separator:a769de03e37e9531ab43625250287ff8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ac98d07dd8f7b70e16ccb9a01abf56b9c">boost::serialization::access</a></td></tr>
<tr class="separator:ac98d07dd8f7b70e16ccb9a01abf56b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f5346f31d572dd2ab4fcd658de5bc4"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ad3f5346f31d572dd2ab4fcd658de5bc4">Serializer</a></td></tr>
<tr class="separator:ad3f5346f31d572dd2ab4fcd658de5bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Cuadro clave, keyframe. </p>
<p>ORB-SLAM identifica algunos cuadros como clave y los agrega al mapa. Un <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a> tiene más datos que un <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html" title="Frame representa un cuadro, una imagen, con los puntos singulares detectados. ">Frame</a>. Al construirse copia los datos del <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html" title="Frame representa un cuadro, una imagen, con los puntos singulares detectados. ">Frame</a>. Los <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html" title="Frame representa un cuadro, una imagen, con los puntos singulares detectados. ">Frame</a> son efímeros, los <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a> perduran en el mapa. <a class="el" href="class_o_r_b___s_l_a_m2_1_1_local_mapping.html" title="LocalMapping tiene una única instancia ejecutando el método Run en su propio thread. ">LocalMapping</a> triangula nuevos puntos del mapa exclusivamente a partir de keyframes, no de frames. <a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html#a8c7fb6c4b1f952524512023df690bf4d" title="Crea un keyframe a partir del frame actual. ">Tracking::CreateNewKeyFrame</a> tiene la exclusividad de la creación de keyframes.</p>
<p>Matrices</p>
<ul>
<li>E: matriz esencial, 3x3</li>
<li>F: matriz fundamental, 3x3</li>
<li>H: homografía, 3x3</li>
<li>K: matriz intrínseca, de cámara o de calibración, 3x3</li>
<li>R: matriz de rotación, 3x3, derivada de una pose</li>
<li>T: transformación, matriz homogénea de 4x4, de rototraslación, para expresar poses</li>
</ul>
<p>Subíndices usuales: <a href="https://github.com/raulmur/ORB_SLAM2/issues/226">https://github.com/raulmur/ORB_SLAM2/issues/226</a></p>
<ul>
<li>Tcw: "pose respecto de Cámara, de World". Vc = Tcw . Vw : convierte Vw en coordenadas del mundo en Vc en coordenadas de la cámara.</li>
<li>F21: "matriz fundamental del cuadro 1 respecto de 2"</li>
</ul>
<p>Vectores:</p>
<ul>
<li>t: traslación, derivada de una pose</li>
</ul>
<p>Origen de coordenadas:</p>
<p>El origen de coordenadas por defecto es el mundo, cuyo origen está dado por la pose de la primer cámara, y la escala por la distancia entre las cámaras de inicialización que triangularon los primeros puntos.</p>
<p>Grafos</p>
<p>Los keyframes se ordenan en tres grafos:</p><ul>
<li>árbol de expansión (spanning tree) mínimo con raíz en el primer keyframe.</li>
<li>grafo de covisibilidad, consistente en ejes ponderados, entre keyframes.</li>
<li>grafo esencial, árbol de expansión con una poda del grafo de covisibilidad</li>
</ul>
<p>El árbol de expansión conecta todos los keyframes sin redundancia. Cada keyframe registra su padre en <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a94bbb0261caf3f1ed0c434c9fca1e886" title="KeyFrame padre en el grafo. ">KeyFrame::mpParent</a> y sus hijos en <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ac647a33b4a6d158b640c5482ed57bbfe" title="KeyFrames hijos en el grafo, que conforman el spanning tree del grado esencial. ">KeyFrame::mspChildrens</a>. Se administra con:</p><ul>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a2394adfb627d9cf87ed8da78f6b0d709" title="Agrega un keyframe hijo al grafo de keyframes KeyFrame::mspChildrens. ">KeyFrame::AddChild</a></li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aefdd69627fd6a204a6ef4539303b81f6" title="Borra un keyframe hijo del grafo KeyFrame::mspChildrens. ">KeyFrame::EraseChild</a></li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a3232df2495062749da1344db3e5a487f" title="Cambia el padre del keyframe en el grafo. ">KeyFrame::ChangeParent</a></li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a618ddd51eab47bf1d84a21d2e818a787" title="Devuelve los hijos de este keyframe. ">KeyFrame::GetChilds</a></li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a660cfc9a6ccf87e5497356d0d98ef06f" title="Informa el keyframe padre. ">KeyFrame::GetParent</a></li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a2276fdbae634194e790878adebba7861" title="Indica si un keyframe es hijo de éste. ">KeyFrame::hasChild</a></li>
</ul>
<p>El grafo de covisibilidad consiste en una conexión desde un keyframe hacia cada keyframe que observa algún punto en común. Las conexiones (ejes del grafo) son ponderadas y se registran en</p><ul>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a6a057195e3e9e7d3f08b97b6366e9f81" title="Mapa de covisibilidad, que vincula los keyframes covisibles con sus pesos. ">KeyFrame::mConnectedKeyFrameWeights</a></li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#af4a83f5b32cf53c0ad87702226b9dff8" title="Keyframes covisibles ordenados por peso, actualizado vía KeyFrame::UpdateBestCovisibles. ">KeyFrame::mvpOrderedConnectedKeyFrames</a></li>
<li>KeyFrame::mvOrderedWeight</li>
</ul>
<p>y se administran con</p><ul>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a8d21a23485b7c104a73d6ad3cccf4e93" title="Conecta el keyframe con otro en el grafo de covisibilidad. ">KeyFrame::AddConnection</a></li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a0a2e676f5e594cf9330e197a2c7df378" title="Elimina del grafo de covisibilidad la conexión con el keyframe dado. ">KeyFrame::EraseConnection</a></li>
<li>KeyFrame::GetVectorCovisibleKeyframes</li>
<li>KeyFrame::GetCovisiblesByWight</li>
</ul>
<p>El grafo esencial está formado por el árbol de expansión, las conexiones fuertes de covisibilidad, y las conexiones de bucle.</p><ul>
<li>KeyFrame::GetBestCovisibleKeyFrames</li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aca519e7486b0e6f1fd6c98d7ced920b8" title="Agrega un eje al grafo de covisibilidad, a partir de una detección de bucle. ">KeyFrame::AddLoopEdge</a></li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ab3109e85b0ab224efdc23e51b5d2c3fa" title="Informa los keyframes conectados con ejes de bucle. ">KeyFrame::GetLoopEdges</a></li>
</ul>
<p>El grafo esencial se utiliza en <a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#a5a53ab409feed7f92547eb79a2d7f6e9" title="Optimiza el grafo esencial para cerrar un bucle. ">Optimizer::OptimizeEssentialGraph</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6b2fd06ed5e4a8f9546c515db554bcb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ORB_SLAM2::KeyFrame::KeyFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html">Frame</a> &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html">Map</a> *&#160;</td>
          <td class="paramname"><em>pMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame_database.html">KeyFrameDatabase</a> *&#160;</td>
          <td class="paramname"><em>pKFDB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor que copia los datos del frame que se convierte en keyframe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">F</td><td><a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html" title="Frame representa un cuadro, una imagen, con los puntos singulares detectados. ">Frame</a> de referencia, que se erige en <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a> </td></tr>
    <tr><td class="paramname">pMap</td><td>Mapa local donde se encuentra este <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a>, necesario solamente para quitar el <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a> del mapa. </td></tr>
    <tr><td class="paramname">pKFDB</td><td>Base de datos de keyframes donde se registran todos los keyframes, necesario solamente para quitar este <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a> de la base de datos. Se registra en mpKeyFrameDB.</td></tr>
  </table>
  </dd>
</dl>
<p>Este constructor copia todos los valores del <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html" title="Frame representa un cuadro, una imagen, con los puntos singulares detectados. ">Frame</a> F. Se invoca sólo desde:</p><ul>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html#afeb077c81cd700d779348b80698086e8" title="Crea el mapa inicial. ">Tracking::CreateInitialMapMonocular</a> para crear los dos primeros keyframes, a partir de los dos cuadros usados en la triangulación de los primeros puntos del mapa.</li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html#a8c7fb6c4b1f952524512023df690bf4d" title="Crea un keyframe a partir del frame actual. ">Tracking::CreateNewKeyFrame</a> para crear todos los demás keyframes, siempre a partir del cuadro actual mCurrentFrame. </li>
</ul>

</div>
</div>
<a id="a3c33a6c79533849d367db9e85fe98c14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ORB_SLAM2::KeyFrame::KeyFrame </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor por defecto para <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a> Se ocupa de inicializar los atributos const, para que el compilador no chille. </p>
<p>Entre ellos inicializa los atributos no serializables (todos punteros a singletons). Luego serialize se encarga de cambiarle los valores, aunque sean const. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2394adfb627d9cf87ed8da78f6b0d709"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::AddChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Agrega un keyframe hijo al grafo de keyframes <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ac647a33b4a6d158b640c5482ed57bbfe" title="KeyFrames hijos en el grafo, que conforman el spanning tree del grado esencial. ">KeyFrame::mspChildrens</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF</td><td>Keyframe hijo a agregar.</td></tr>
  </table>
  </dd>
</dl>
<p>Invocado sólo desde</p><ul>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a3232df2495062749da1344db3e5a487f" title="Cambia el padre del keyframe en el grafo. ">ORB_SLAM2::KeyFrame::ChangeParent</a></li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#afe7026956c91d4e0a01812be9dc7e8d5" title="Releva la covisibilidad y crea las conexiones en el grafo de covisibilidad. ">ORB_SLAM2::KeyFrame::UpdateConnections</a> </li>
</ul>

</div>
</div>
<a id="a8d21a23485b7c104a73d6ad3cccf4e93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::AddConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conecta el keyframe con otro en el grafo de covisibilidad. </p>
<p>El grafo de covisibilidad es un mapa de pares keyframe y peso <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a6a057195e3e9e7d3f08b97b6366e9f81" title="Mapa de covisibilidad, que vincula los keyframes covisibles con sus pesos. ">KeyFrame::mConnectedKeyFrameWeights</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF</td><td>Keyframe a conectar. </td></tr>
    <tr><td class="paramname">weight</td><td>Peso o ponderación de la conexión.</td></tr>
  </table>
  </dd>
</dl>
<p>AddConnection agrega otro keyframe al grafo de covisibilidad de este keyframe.</p>
<p>Invocado sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#afe7026956c91d4e0a01812be9dc7e8d5" title="Releva la covisibilidad y crea las conexiones en el grafo de covisibilidad. ">KeyFrame::UpdateConnections</a>. </p>

</div>
</div>
<a id="aca519e7486b0e6f1fd6c98d7ced920b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::AddLoopEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Agrega un eje al grafo de covisibilidad, a partir de una detección de bucle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF</td><td>Keyframe con el que tender el eje.</td></tr>
  </table>
  </dd>
</dl>
<p>Sólo invocado por <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#aa007e0678582ec0de5d71280d23af540" title="Corrige el bucle con los encastres elaborados por LoopClosing::ComputeSim3. ">LoopClosing::CorrectLoop()</a>. </p>

</div>
</div>
<a id="a16ea4f0cfa1ca411bb3382107fe69d2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::AddMapPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&#160;</td>
          <td class="paramname"><em>pMP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Agrega un punto 3D a la lista de puntos observados. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMP</td><td>Punto 3D a agregar al keyframe. </td></tr>
    <tr><td class="paramname">idx</td><td>Índice del punto en el vector de puntos 3D, también índice del punto singular asociado. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fd4bcef13a79d08e78307cc3d77349b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::buildObservations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconstruye las observaciones de los puntos observados por el keyframe. </p>
<p>Usado exclusivamente en la serialización, para reconstruir datos redundantes.</p>
<p>Los keyframes registran los puntos obervados, y éstos registran los keyframes que los observan. Sólo los primeros se serializan, los segundos se reconstruyen con este método.</p>
<p>Invocado sólo por <a class="el" href="class_o_r_b___s_l_a_m2_1_1_serializer.html#a0abab31e1f3f6597b18de573701cb14b" title="Carga el mapa desde el archivo binario. ">Serializer::mapLoad</a> </p>

</div>
</div>
<a id="a3232df2495062749da1344db3e5a487f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::ChangeParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cambia el padre del keyframe en el grafo. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF</td><td>Nuevo keyframe padre.</td></tr>
  </table>
  </dd>
</dl>
<p>Este método cambia el valor de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a94bbb0261caf3f1ed0c434c9fca1e886" title="KeyFrame padre en el grafo. ">KeyFrame::mpParent</a>, y se registra como hijo del nuevo padre.</p>
<p>No se desregistra del viejo padre, que usualmente dejó de existir.</p>
<p>Invocado sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a365ec4d06acbbcd668aa5a069c69fdaa" title="Intenta eliminar el keyframe y marcarlo como malo. ">ORB_SLAM2::KeyFrame::SetBadFlag()</a>, al remendar el grafo. </p>

</div>
</div>
<a id="ac376017c23823c05a6bb851ffb2fdd8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::ComputeBoW </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computa BoW para los descriptores del keyframe. </p>
<p>Genera los mapas <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a70cb0dee48e804c5b1f30afd0ce99787" title="Vector de BoW obtenidos de los descriptores del keyframe. ">KeyFrame::mBowVec</a> y <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a3588bf0a927e8ab838c614565ee7de20" title="Vector de Features de DBoW2. ">KeyFrame::mFeatVec</a>, el primero con los BoW y sus pesos, el segundo con la lista de puntos singulares correspondiente a cada BoW.</p>
<p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html#ac748d2318f9a409406dba4910ff5ef8e" title="Computa BoW para todos los descriptores del cuadro. ">Frame::ComputeBoW</a> hace exactamente lo mismo, pero no se ejecuta para todos los cuadros, solamente para el cuadro actual cuando está perdido y se necesita relocalizar. El constructor de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a> copia los mapas de BoW, y este método evita recomputarlos si casualmente ya se computaron para el cuadro.</p>
<p>Es invocado sólo desde:</p><ul>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_local_mapping.html#a84eea8f268cce9d919a4906ae634dd22" title="Crea un keyframe a partir del cuadro actual LocalMapping::mpCurrentKeyFrame. ">LocalMapping::ProcessNewKeyFrame</a></li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html#afeb077c81cd700d779348b80698086e8" title="Crea el mapa inicial. ">Tracking::CreateInitialMapMonocular</a> </li>
</ul>

</div>
</div>
<a id="aa4c5f9ea38d377cfa70d441e184803ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ORB_SLAM2::KeyFrame::ComputeSceneMedianDepth </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computa la profundidad del punto mediano de la escena. </p>
<p>La escena es el conjunto de puntos 3D observador por el keyframe.</p>
<p>La profundidad de un punto 3D respecto de una pose de cámara es la distancia de ese punto al plano paralelo a la imagen de la cámara, que pasa por su foco.</p>
<p>Calcula la profundidad para cada punto del mundo, los ordena por profundidad y devuelve la profundidad del punto 1/q.</p>
<p>Fallaría si no hubiera ningún punto 3D en la escena.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>Fraccionador, q&gt;=1, que elige qué profundidad devolver. 1 devuelve la del más lejano, infinito la del más cercano, 2 la mediana. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Profundidad del punto elegido.</dd></dl>
<p>Se invoca desde dos lugares, siempre con el argumento q=2.</p>
<p>Desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html#afeb077c81cd700d779348b80698086e8" title="Crea el mapa inicial. ">Tracking::CreateInitialMapMonocular</a> se usa esta profundidad para establecer la unidad de medida del mundo. Desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_local_mapping.html#ac06b513357429d9eff89e29d2ae58d6c" title="El ciclo de mapeo local invoca periódicamente este método, que busca macheos candidatos para su trian...">LocalMapping::CreateNewMapPoints</a> se usa para descartar la triangulación de un par de keyframes. </p>

</div>
</div>
<a id="aefdd69627fd6a204a6ef4539303b81f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::EraseChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Borra un keyframe hijo del grafo <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ac647a33b4a6d158b640c5482ed57bbfe" title="KeyFrames hijos en el grafo, que conforman el spanning tree del grado esencial. ">KeyFrame::mspChildrens</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF</td><td>Keyframe hijo a borrar. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a2e676f5e594cf9330e197a2c7df378"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::EraseConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elimina del grafo de covisibilidad la conexión con el keyframe dado. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF</td><td>Keyframe a desconectar.</td></tr>
  </table>
  </dd>
</dl>
<p>Invocado sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a365ec4d06acbbcd668aa5a069c69fdaa" title="Intenta eliminar el keyframe y marcarlo como malo. ">KeyFrame::SetBadFlag</a>. </p>

</div>
</div>
<a id="a2fd38a2bca9f5ced2f1f7501b8046195"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::EraseMapPointMatch </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reemplaza el punto del índice por NULL en el vector mvpMapPoints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Índice del punto a eliminar.</td></tr>
  </table>
  </dd>
</dl>
<p>Es una función final, se limita a reemplazar el elemento indicado por NULL.</p>
<p>Invocada sólo pro <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html#a8f2e205afcfae3dc70196bcd29194440" title="Reemplaza este punto por el punto argumento, en una fusión. ">MapPoint::Replace</a> y <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html#a7ed2a66b528165d6c39cb6f84f684308" title="Elimina el punto, marcándolo como malo. ">MapPoint::SetBadFlag</a>. </p>

</div>
</div>
<a id="ab3a775e959978e6d449386882e45b8a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::EraseMapPointMatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&#160;</td>
          <td class="paramname"><em>pMP</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Quita el punto de la lista de puntos observados por este keyfame. </p>
<p>Reemplaza el punto por NULL en el vector mvpMapPoints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMP</td><td>Punto 3D a eliminar del vector de puntos 3D observados.</td></tr>
  </table>
  </dd>
</dl>
<p>Si no lo encuentra no hace nada. Para borrar le punto, el keyframe debe poder encontrarse en sus observaciones. Si no se encuentra, el punto no se borra.</p>
<p>Es una función final, no procura coherencia con otros contenedores.</p>
<p>Invocado sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#ab70e0b4f366b65a0c1ae8b2def19d339" title="Bundle adjusment local a partir de un keyframe. ">ORB_SLAM2::Optimizer::LocalBundleAdjustment</a> para eliminar outliers. </p>

</div>
</div>
<a id="a2ecb2df01af804fb727c93948a28475f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> * &gt; ORB_SLAM2::KeyFrame::GetBestCovisibilityKeyFrames </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve los primeros y mejores N elementos del vector de keyframes covisibles <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#af4a83f5b32cf53c0ad87702226b9dff8" title="Keyframes covisibles ordenados por peso, actualizado vía KeyFrame::UpdateBestCovisibles. ">KeyFrame::mvpOrderedConnectedKeyFrames</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Cantidad máxima de keyframes a devolver.</td></tr>
  </table>
  </dd>
</dl>
<p>Ordena las conexiones por peso. </p>

</div>
</div>
<a id="a535f0f7db34aca7c55ddadc2ad9f4a5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ORB_SLAM2::KeyFrame::GetCameraCenter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lee el vector centro de cámara, igual al vector traslación para monocular. </p>
<dl class="section return"><dt>Returns</dt><dd>el vector de posición de la cámara, igual a la traslación. Es diferente sólo en estéreo. </dd></dl>

</div>
</div>
<a id="a618ddd51eab47bf1d84a21d2e818a787"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> * &gt; ORB_SLAM2::KeyFrame::GetChilds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve los hijos de este keyframe. </p>
<dl class="section return"><dt>Returns</dt><dd>Keyframes hijos. </dd></dl>

</div>
</div>
<a id="af4ffdf4441477a36c42d6605c573f1cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> * &gt; ORB_SLAM2::KeyFrame::GetConnectedKeyFrames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve un conjunto de keyframes conectados a éste por el grafo esencial. </p>

</div>
</div>
<a id="a7047bffbf130b00dd0270df99874f8a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> * &gt; ORB_SLAM2::KeyFrame::GetCovisiblesByWeight </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve los mejores elementos del vector de keyframes covisibles, con peso mejor al de referencia. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Peso de referencia. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa057f2902cc7910343c5d452d33cb39f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; size_t &gt; ORB_SLAM2::KeyFrame::GetFeaturesInArea </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filtra puntos singulares que estén en el cuadrado de centro x,y y lado 2 r. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Coordenada del centro del cuadrado. </td></tr>
    <tr><td class="paramname">y</td><td>Coordenada del centro del cuadrado. </td></tr>
    <tr><td class="paramname">r</td><td>Longitud de medio lado del cuadrado. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector de índices de los puntos singulares en el área cuadrada. </dd></dl>

</div>
</div>
<a id="ab3109e85b0ab224efdc23e51b5d2c3fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> * &gt; ORB_SLAM2::KeyFrame::GetLoopEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Informa los keyframes conectados con ejes de bucle. </p>
<dl class="section return"><dt>Returns</dt><dd>Keyframes conectados por ejes de bucles. </dd></dl>

</div>
</div>
<a id="ab85915f3e647334634d8a4d489c63ffd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> * ORB_SLAM2::KeyFrame::GetMapPoint </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve el punto 3D a partir del índice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Índice para el vector <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a777aab9cb7c1fd8e83f143e77a9f1b03" title="Puntos del mapa asociado a los puntos singulares. ">KeyFrame::mvpMapPoints</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Punto 3D. </dd></dl>

</div>
</div>
<a id="aabc5f6491c32999d9f546669737547bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> * &gt; ORB_SLAM2::KeyFrame::GetMapPointMatches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve una copia del vector de puntos 3D. </p>
<dl class="section return"><dt>Returns</dt><dd>Copia de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a777aab9cb7c1fd8e83f143e77a9f1b03" title="Puntos del mapa asociado a los puntos singulares. ">KeyFrame::mvpMapPoints</a>.</dd></dl>
<p>Es ampliamente utilizado. </p>

</div>
</div>
<a id="a09cb77a8377be3fa8c85c7b5ee45e913"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> * &gt; ORB_SLAM2::KeyFrame::GetMapPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve los puntos 3D observados por el keyframe. </p>
<p>Recorre el vector <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a777aab9cb7c1fd8e83f143e77a9f1b03" title="Puntos del mapa asociado a los puntos singulares. ">KeyFrame::mvpMapPoints</a> y genera un set, copiando los elementos no NULL. </p><dl class="section return"><dt>Returns</dt><dd>set de puntos 3D. </dd></dl>

</div>
</div>
<a id="a660cfc9a6ccf87e5497356d0d98ef06f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> * ORB_SLAM2::KeyFrame::GetParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Informa el keyframe padre. </p>
<dl class="section return"><dt>Returns</dt><dd>Keyframe padre. </dd></dl>

</div>
</div>
<a id="a49b5e212c1335cf585eaf6bbc4fed85c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ORB_SLAM2::KeyFrame::GetPose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lee Tcw, la pose del keyframe. </p>
<dl class="section return"><dt>Returns</dt><dd>Tcw, la pose. </dd></dl>

</div>
</div>
<a id="a03be061f5dac65d360d65c6e8a63532f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ORB_SLAM2::KeyFrame::GetPoseInverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lee Twc, la matriz inversa de la pose. </p>
<dl class="section return"><dt>Returns</dt><dd>Twc, la inversa de la pose. </dd></dl>

</div>
</div>
<a id="a43cdfc1cebc87d949ae6e9a0202b0f1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ORB_SLAM2::KeyFrame::GetRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lee la matriz rotación 3D, obtenida de Tcw. </p>
<dl class="section return"><dt>Returns</dt><dd>R, la matriz rotación 3D de 3x3, parte de la pose.</dd></dl>
<p>La matriz rotación rota un vector </p>

</div>
</div>
<a id="a6f1426dc5447170df37c31db40edef14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ORB_SLAM2::KeyFrame::GetTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lee el vector traslación, obtenido de Tcw. </p>

</div>
</div>
<a id="a9315d396634f6637f70f716336777b8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> * &gt; ORB_SLAM2::KeyFrame::GetVectorCovisibleKeyFrames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve el vector de keyframes covisibles <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#af4a83f5b32cf53c0ad87702226b9dff8" title="Keyframes covisibles ordenados por peso, actualizado vía KeyFrame::UpdateBestCovisibles. ">KeyFrame::mvpOrderedConnectedKeyFrames</a> . </p>

</div>
</div>
<a id="ab10fd3aab6431face352a930961ff713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::KeyFrame::GetWeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Informa el peso de la conexión de un determinado keyframe covisible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF</td><td>Keyframe cuyo peso se quiere conocer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Peso del keyframe. </dd></dl>

</div>
</div>
<a id="a2276fdbae634194e790878adebba7861"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ORB_SLAM2::KeyFrame::hasChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indica si un keyframe es hijo de éste. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF</td><td>Keyframe presunto hijo. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si es hijo, false si no. </dd></dl>

</div>
</div>
<a id="a95c437e42b4894a4acc9f05af61e9963"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ORB_SLAM2::KeyFrame::isBad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consulta la marca mbBad. </p>
<p>true si es malo. Cuando el keyframe es malo, se lo ignora sin excepciones en orb-slam2. Equivaldría a eliminar la instancia, pero eso puede romper algún puntero efímero. La serialización es un buen momento para quitar los malos.</p>
<p>Si esta marca es true, el keyframe se ha eliminado de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html" title="Mapa del mundo, de puntos y keyframes. ">Map</a>, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame_database.html" title="Lista invertida de KeyFrames, accesible por BoW. ">KeyFrameDatabase</a>, de las observaciones de todos los <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html" title="Cada instancia representa un mapa 3D en el sistema de referencia del mapa. ">MapPoint</a> y del spanning tree. </p>

</div>
</div>
<a id="ab3be661e9ce7fb1809bb39a5e6fde7fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ORB_SLAM2::KeyFrame::IsInImage </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifica si la coordenada está dentro del área de la imagen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Coordenada x. </td></tr>
    <tr><td class="paramname">y</td><td>Coordenada y. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si la coordenada está dentro del área de la imagen, false si no. </dd></dl>

</div>
</div>
<a id="a921334deb73b3103f5a78322eab9bc99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ORB_SLAM2::KeyFrame::lId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a> *&#160;</td>
          <td class="paramname"><em>pKF2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compara Id. </p>
<p>Menor id, mayor antigüedad. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pKF1</td><td>keyframe 1. </td></tr>
    <tr><td class="paramname">pKF2</td><td>keyframe 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true si pKF1 es más antiguo que pKF2. </dd></dl>

</div>
</div>
<a id="a35779a4eb4f5cec346780bbbdf377298"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::ReplaceMapPointMatch </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a> *&#160;</td>
          <td class="paramname"><em>pMP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reemplaza un elemento de los puntos observador por un nuevo punto 3D. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Índice del punto a reemplazar. </td></tr>
    <tr><td class="paramname">pMP</td><td>Nuevo punto que reemplaza al anterior. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a338bacd1855d45c7a1cc38b9ba47a46e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03bbcbd5f862204ac10985a51d8cd74f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archivo &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::serialize </td>
          <td>(</td>
          <td class="paramtype">Archivo &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>int</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Serializador para <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a>. </p>
<p>Invocado al serializar <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html#abf1d31c2cb4df61d232bb7fbd7cfb61d" title="KeyFrames del mapa. ">Map::mspKeyFrames</a>. No guarda mpKeyFrameDB, que se debe asignar de otro modo. </p>

</div>
</div>
<a id="a365ec4d06acbbcd668aa5a069c69fdaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::SetBadFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intenta eliminar el keyframe y marcarlo como malo. </p>
<p>Con esta marca los algoritmos lo ignorarán.</p>
<p>Se se permite eliminar el keyframe:</p><ul>
<li>se retira del mapa</li>
<li>se retira de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame_database.html" title="Lista invertida de KeyFrames, accesible por BoW. ">KeyFrameDatabase</a></li>
<li>se remienda el grafo de keyframes eligiendo nuevos padres para los hijos.</li>
<li>se quita de las observaciones de cada <a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html" title="Cada instancia representa un mapa 3D en el sistema de referencia del mapa. ">MapPoint</a> de mvpMapPoints</li>
<li>se marca mbBad</li>
</ul>
<p>El objeto en sí no se elimina nunca, aunque debería. No se libera porque no tiene modo de asegurar que nadie lo está accediendo. Una manera sería crear un vector de keyframes huérfanos con un timestamp de su deceso, y comparar con timestamps de hilos que podrían usarlo.</p>
<p>El flag mbBad sirve cuando se accede a un keyframe que justo en ese momento se está borrando desde otro hilo.</p>
<p>Si se previene la eliminación de ese keyframe (mbNotErase == true), se marca para su eliminación inmediata apenas se libere: KeyFrame::Erase libera el keyframe, verifica la marca mbToBeErase, y si es true vuelve a invocar SetBadFlag. Este sistema de prevención de eliminación se usa solamente durante el proceso de detección de bucles, de manera temporal. Cuando un keyframe queda enganchado en un bucle, este sistema prevendrá su eliminación para siempre.</p>
<p>No tiene efecto sobre el keyframe inicial, con id 0.</p>
<p>SetBadFlag bloquea mMutexConnections y mMutexFeatures, y marca mbBad antes de desbloquear. Curiosamente los métodos que utilizan este lock no consultan la marca mbBad antes de proceder. Esto podría explicar el bug por el que perduran en el grafo algunos keyframes marcados como malos.</p>
<p>Invocado sólo por <a class="el" href="class_o_r_b___s_l_a_m2_1_1_local_mapping.html#aca73e5b4bace436b235dfa9c9a522b19" title="Elimina keyframes redundantes, que no agregan información. ">LocalMapping::KeyFrameCulling</a> y <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a9424cf54c979bc87df12b48e3827e834" title="Libera el keyframe previamente marcado con KeyFrame::SetNotErase. ">KeyFrame::SetErase</a>.</p>
<p>TODO: Convendría realizar la eliminación del keyframe del mapa antes que nada, de manera reducir la probabilidad de que otros hilos lo encuentren. Del mismo modo, se debería marcar como Bad desde el principio. </p>

</div>
</div>
<a id="a9424cf54c979bc87df12b48e3827e834"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::SetErase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Libera el keyframe previamente marcado con <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aa64c7adb5f80f260cb7e997f68881b09" title="Previene la eliminación del keyframe mientras se utiliza en una detección de bucle. ">KeyFrame::SetNotErase</a>. </p>
<p>Hace mbNotErase = false, sólo si el keyframe no está conectado por ejes de bucle a otros keyframes.</p>
<p>Aprovecha el momento y verifica si el keyframe está marcado para borrado, en cuyo caso invoca SetBadFlag.</p>
<p>SetErase es un paso anterior a SetBadFlag, invocado solamente desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html" title="Cierre de bucles. ">LoopClosing</a>. Invocado repetidamente sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#aa8110ca79cebaf509e378d30e55f1381" title="Procesa los keyframes de la cola, buscando bucles. ">LoopClosing::DetectLoop</a> y <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#ab4fcf814eed5b5dd2aec96454561b078" title="Procesa la lista de candidatos intentando corregir su pose. ">LoopClosing::ComputeSim3</a> para liberar el keyframe.</p>
<p>DetectLoop sólo lo invoca sobre mpCurrentKF.</p>
<p>Estos dos métodos marcan keyframes para no borrar y los liberan al final con <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a9424cf54c979bc87df12b48e3827e834" title="Libera el keyframe previamente marcado con KeyFrame::SetNotErase. ">KeyFrame::SetErase</a>, excepto que el keyframe termine formando parte de un cierre de bucle, en cuyo caso quedará marcado para siempre. </p>

</div>
</div>
<a id="aa64c7adb5f80f260cb7e997f68881b09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::SetNotErase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Previene la eliminación del keyframe mientras se utiliza en una detección de bucle. </p>
<p>Hace mbNotErase = true.</p>
<p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html" title="Cierre de bucles. ">LoopClosing</a> previene el borrado de los keyframes considerados marcándolos con <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aa64c7adb5f80f260cb7e997f68881b09" title="Previene la eliminación del keyframe mientras se utiliza en una detección de bucle. ">KeyFrame::SetNotErase</a> antes de procesarlos, y liberándolos al final con <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a9424cf54c979bc87df12b48e3827e834" title="Libera el keyframe previamente marcado con KeyFrame::SetNotErase. ">KeyFrame::SetErase</a>.</p>
<p>Invocado sólo desde <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#aa8110ca79cebaf509e378d30e55f1381" title="Procesa los keyframes de la cola, buscando bucles. ">LoopClosing::DetectLoop</a> y <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#ab4fcf814eed5b5dd2aec96454561b078" title="Procesa la lista de candidatos intentando corregir su pose. ">LoopClosing::ComputeSim3</a>. DetectLoop lo invoca sólo sobre mpCurrentKF </p>

</div>
</div>
<a id="aa799150fa33f3b9a404226454b96c95a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::SetPose </td>
          <td>(</td>
          <td class="paramtype">const cv::Mat &amp;&#160;</td>
          <td class="paramname"><em>Tcw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establece Tcw, la pose del keyframe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Tcw</td><td>Matriz de pose de la cámara respecto del mundo.</td></tr>
  </table>
  </dd>
</dl>
<p>Este método también calcula otras formas de expresión de la pose:</p><ul>
<li>Twc</li>
<li>Ow</li>
</ul>
<p>Invocado sólo desde:</p><ul>
<li>constructor</li>
<li>optimizaciones y correcciones de pose de BA local</li>
<li>cierre de bucle</li>
<li>al crear el mapa inicial </li>
</ul>

</div>
</div>
<a id="a729cbf2c84db5cbfdda98a9612f8cd0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::KeyFrame::TrackedMapPoints </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>minObs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indica la cantidad de puntos 3D que tengan como mínimo una cantidad dada de observaciones. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minObs</td><td>Cantidad mínima de observaciones </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cantidad de puntos 3D con al menos esa cantidad mínima de observaciones. </dd></dl>

</div>
</div>
<a id="a09cb8502509c136536bf8d45793f8872"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::UpdateBestCovisibles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actualiza los mejores covisibles. </p>
<p>El grafo de covisibilidad es un mapa. Este método produce dos vectores alineados:</p><ul>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#af4a83f5b32cf53c0ad87702226b9dff8" title="Keyframes covisibles ordenados por peso, actualizado vía KeyFrame::UpdateBestCovisibles. ">KeyFrame::mvpOrderedConnectedKeyFrames</a> con los keyframes</li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aeac0492454556dc98bb6bd895acfec9b" title="Pesos de los keyframes de KeyFrame::mvpOrderedConnectedKeyFrames. ">KeyFrame::mvOrderedWeights</a> con sus respectivos pesos</li>
</ul>
<p>Sólo usa datos de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a6a057195e3e9e7d3f08b97b6366e9f81" title="Mapa de covisibilidad, que vincula los keyframes covisibles con sus pesos. ">KeyFrame::mConnectedKeyFrameWeights</a>.</p>
<p>Invocado cada vez que se actualiza el grafo (cada que que se agrega o elimina una conexión), desde:</p><ul>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a8d21a23485b7c104a73d6ad3cccf4e93" title="Conecta el keyframe con otro en el grafo de covisibilidad. ">KeyFrame::AddConnection</a></li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a0a2e676f5e594cf9330e197a2c7df378" title="Elimina del grafo de covisibilidad la conexión con el keyframe dado. ">KeyFrame::EraseConnection</a> </li>
</ul>

</div>
</div>
<a id="afe7026956c91d4e0a01812be9dc7e8d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ORB_SLAM2::KeyFrame::UpdateConnections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releva la covisibilidad y crea las conexiones en el grafo de covisibilidad. </p>
<p>Crea <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#af4a83f5b32cf53c0ad87702226b9dff8" title="Keyframes covisibles ordenados por peso, actualizado vía KeyFrame::UpdateBestCovisibles. ">KeyFrame::mvpOrderedConnectedKeyFrames</a>, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aeac0492454556dc98bb6bd895acfec9b" title="Pesos de los keyframes de KeyFrame::mvpOrderedConnectedKeyFrames. ">KeyFrame::mvOrderedWeights</a> y <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a6a057195e3e9e7d3f08b97b6366e9f81" title="Mapa de covisibilidad, que vincula los keyframes covisibles con sus pesos. ">KeyFrame::mConnectedKeyFrameWeights</a>.</p>
<p>Recorre todos los mapPoints vistos por este keyframe, y releva todos los otros keyframes que los observan, creando así el mapa de covisibilidad <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a6a057195e3e9e7d3f08b97b6366e9f81" title="Mapa de covisibilidad, que vincula los keyframes covisibles con sus pesos. ">KeyFrame::mConnectedKeyFrameWeights</a>.</p>
<p>Se agrega a sí mismo al mapa de cada keyframe relevado, invocando sus respectivos métodos <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a8d21a23485b7c104a73d6ad3cccf4e93" title="Conecta el keyframe con otro en el grafo de covisibilidad. ">KeyFrame::AddConnection</a>. Este accionar debería garantizar la doble referencia.</p>
<p>Es invocado por:</p>
<ul>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html#afeb077c81cd700d779348b80698086e8" title="Crea el mapa inicial. ">ORB_SLAM2::Tracking::CreateInitialMapMonocular()</a> : void (2 matches), al crear lso primeros keyframes del mapa inicial.</li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_local_mapping.html#a84eea8f268cce9d919a4906ae634dd22" title="Crea un keyframe a partir del cuadro actual LocalMapping::mpCurrentKeyFrame. ">ORB_SLAM2::LocalMapping::ProcessNewKeyFrame()</a> : void, cuando se crea el <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a> (de manera asincrónica).</li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_local_mapping.html#a5d5e0bc6fd15d9a6bf1ca8a258f104f1" title="Recorre los keyframes vecinos buscando puntos para fusionar. ">ORB_SLAM2::LocalMapping::SearchInNeighbors()</a> : void.</li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#aa007e0678582ec0de5d71280d23af540" title="Corrige el bucle con los encastres elaborados por LoopClosing::ComputeSim3. ">ORB_SLAM2::LoopClosing::CorrectLoop()</a> : void (3 matches), al cerrar un bucle se debe rehacer el grafo de covisibilidad.</li>
</ul>
<p>Quizás el cierre de bucle podría interferir con una llamada simultánea de parte de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_local_mapping.html" title="LocalMapping tiene una única instancia ejecutando el método Run en su propio thread. ">LocalMapping</a>. Por eso emplea mutex.</p>
<p>Respecto del posibles solapamiento son SetBadFlag:</p>
<p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html" title="Cierre de bucles. ">LoopClosing</a> marca el keyframe con SetNotErase. Esa marca perdura en SearchInNeighbors, por lo que no hay interferencia posible. ProcessNewKeyFrame crea el keyframe, es imposible que en ese momento se marque como malo. Tampoco hay interferencia posible. </p>

</div>
</div>
<a id="ad2d0287d1ca4a91cd9d684754c84a08b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ORB_SLAM2::KeyFrame::weightComp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compara dos pesos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Peso a. </td></tr>
    <tr><td class="paramname">b</td><td>Peso b. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a&gt;b. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac98d07dd8f7b70e16ccb9a01abf56b9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class boost::serialization::access</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3f5346f31d572dd2ab4fcd658de5bc4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_o_r_b___s_l_a_m2_1_1_serializer.html">Serializer</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a44b4e47236003fc55a655092b28b18f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="namespace_d_bo_w2.html#a55fcd7333e591a38e96b91f41bc182f6">DBoW2::WordValue</a>&gt; ORB_SLAM2::KeyFrame::bowPesos</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector alineado de pesos de BoW. </p>
<p>Cada elemento es un peso, correspondiente al BoW del punto singular.</p>
<p><a class="el" href="namespace_d_bo_w2.html#a55fcd7333e591a38e96b91f41bc182f6" title="Value of a word. ">DBoW2::WordValue</a> es double.</p>
<p>Generado por la versión modificada de KeyFrame::ComputeBow.</p>
<p>Usado exclusivamente para puntos lejanos. </p>

</div>
</div>
<a id="aaf26de59fea866af8efad6006250c40c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="namespace_d_bo_w2.html#ab1a0d3283b2d4690a383372ed20bfeb5">DBoW2::WordId</a>&gt; ORB_SLAM2::KeyFrame::bows</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector alineado de BoW. </p>
<p>Cada elemento es un BoW, correspondiente a un punto singular.</p>
<p><a class="el" href="namespace_d_bo_w2.html#ab1a0d3283b2d4690a383372ed20bfeb5" title="Id of words. ">DBoW2::WordId</a> es unsigned int.</p>
<p>Generado por la versión modificada de KeyFrame::ComputeBow.</p>
<p>Usado exclusivamente para puntos lejanos. </p>

</div>
</div>
<a id="a70011d4f3a151dd374c684e258aab4a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float ORB_SLAM2::KeyFrame::cx</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae78735c57b92b2d5960ed21c97dfe6a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float ORB_SLAM2::KeyFrame::cy</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a951e9ac5670b8543a7386dee5714da0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float ORB_SLAM2::KeyFrame::fx</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parámetros de calibración. </p>

</div>
</div>
<a id="ab1acd1b8dad098299d350f67dc4517c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float ORB_SLAM2::KeyFrame::fy</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a00ce06c4d206f7ddb1daeeb7c43eb074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float ORB_SLAM2::KeyFrame::invfx</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b96f772fad3b9b816dae9f8a719a15d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float ORB_SLAM2::KeyFrame::invfy</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ed66ca840fb2288ee6b700bb4fc6858"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ORB_SLAM2::KeyFrame::mbBad</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag de eliminación. </p>
<p>Cuando <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a365ec4d06acbbcd668aa5a069c69fdaa" title="Intenta eliminar el keyframe y marcarlo como malo. ">KeyFrame::SetBadFlag</a> no puede elmimnar un keyframe porque está marcado con KeyFrame::mbSetNotErase, pone en true este flag, para reintentar la eliminación apenas se quite la marca mencionada.</p>
<p>Todas las actividades que envuelven un keyframe consultan primero este flag antes de proceder, mediante KeyFrame::IsBad. </p>

</div>
</div>
<a id="a9ad3ef1653d6cfa622994bd2c1bd67c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ORB_SLAM2::KeyFrame::mbFirstConnection</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estado del autómata de inicialización. </p>
<p>true al construirse el keyframe, false a partir de que se le agrega la primer conexión, excepto que sea el keyframe de id 0, que no tiene con quién conectarse y esta marca permanece siempre en true. </p>

</div>
</div>
<a id="aecf677dc6fdd14e6122d0f5e09c01850"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ORB_SLAM2::KeyFrame::mbNotErase</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Señal de no borrar. </p>
<p>Se hace true cuando se le agrega un eje al grafo, o con <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aa64c7adb5f80f260cb7e997f68881b09" title="Previene la eliminación del keyframe mientras se utiliza en una detección de bucle. ">SetNotErase()</a> cuando se usa el keyframe en detección de bucle. Se hace false con <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a9424cf54c979bc87df12b48e3827e834" title="Libera el keyframe previamente marcado con KeyFrame::SetNotErase. ">SetErase()</a>, sólo si no tiene algún eje de bucle. Los keyframes se marcan para no borrar momentáneamente cuando se consideran en un bucle, y se desmarcan cuando falla el cierre. Si el bucle se cierra, los keyframes invoclucrados quedan marcados para siempre. </p>

</div>
</div>
<a id="a70cb0dee48e804c5b1f30afd0ce99787"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_bo_w2_1_1_bow_vector.html">DBoW2::BowVector</a> ORB_SLAM2::KeyFrame::mBowVec</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector de BoW obtenidos de los descriptores del keyframe. </p>
<p>ComputeBoW llena este vector.</p>
<p>BowVector es un mapa de Word Id (unsigned int) a Word value (double), que representa un peso.</p>
<p>Este peso se utiliza solamente para relocalización y cierre de bucle, siempre a través de <a class="el" href="class_d_bo_w2_1_1_templated_vocabulary.html#aedde9cc3255e41fd0441055eeb640346" title="Returns the score of two vectors. ">ORBVocabulary::score</a>, que compara dos BowVector completos.</p>
<p>Word Id es la palabra BoW. </p>

</div>
</div>
<a id="ae282bb579271984c9ee0d55bac7f5dee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ORB_SLAM2::KeyFrame::mbToBeErased</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marca el keyframe para ser borrado. </p>
<p>Los keyframes se construyen con este bit en false. Se pone true solamente con SetBadFlag, cuando mbNotErase es true. Este flag indica que el keyframe está pendiente de borrado, no se pudo borrar porque tenía eje de bucle o estaba siendo usado en una detección de bucle en ese momento.</p>
<p>Reconstruíble: true si tiene ejes de bucle. </p>

</div>
</div>
<a id="a6a057195e3e9e7d3f08b97b6366e9f81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a>*,int&gt; ORB_SLAM2::KeyFrame::mConnectedKeyFrameWeights</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mapa de covisibilidad, que vincula los keyframes covisibles con sus pesos. </p>
<p>Generado completamente vía <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#afe7026956c91d4e0a01812be9dc7e8d5" title="Releva la covisibilidad y crea las conexiones en el grafo de covisibilidad. ">KeyFrame::UpdateConnections</a>, que invoca a <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a8d21a23485b7c104a73d6ad3cccf4e93" title="Conecta el keyframe con otro en el grafo de covisibilidad. ">KeyFrame::AddConnection</a>. Se genera a partir de las observaciones de los puntos del mapa del keyframe. Al generarse se actualiza el mismo mapa de los otros keyframes. </p>

</div>
</div>
<a id="ae08ac0ce59e2c003c182f946de3b3bc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cv::Mat ORB_SLAM2::KeyFrame::mDescriptors</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Descriptores. </p>
<p>Se corresponden con los de mvKeys. </p>

</div>
</div>
<a id="a3588bf0a927e8ab838c614565ee7de20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_d_bo_w2_1_1_feature_vector.html">DBoW2::FeatureVector</a> ORB_SLAM2::KeyFrame::mFeatVec</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector de Features de <a class="el" href="namespace_d_bo_w2.html" title="File: BowVector.cpp Date: March 2011 Author: Dorian Galvez-Lopez Description: bag of words vector Lic...">DBoW2</a>. </p>
<p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ac376017c23823c05a6bb851ffb2fdd8f" title="Computa BoW para los descriptores del keyframe. ">KeyFrame::ComputeBoW</a> llena este vector.</p>
<p>FeatureVector es un mapa de nodos (NodeId, entero) con un vector de índices de puntos singulares asociados.</p>
<p>A este vector no se accede por el índice de un punto singular, sino al revés: se accede por NodoId, y se obtienen los índices de todos los puntos singulares con ese NodeId.</p>
<p>Cada BoW tiene un NodeId biunívoco. Pero hay NodeId sin BoW, pues no son hojas del árbol de vocabulario. Sin embargo <a class="el" href="class_d_bo_w2_1_1_templated_vocabulary.html#a01de3bebec37624439c7d3baf6651ff0" title="Transforms a set of descriptores into a bow vector. ">ORBVocabulary::transform</a> sólo registra nodos hoja, es decir con BoW asociado. mFeacVec y mBowVec tienen el mismo tamaño. Si bien se pueblan alineados, al ser mapas el orden se altera. </p>

</div>
</div>
<a id="a89412cd7a6d467c262a7c3a584c81990"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float ORB_SLAM2::KeyFrame::mfGridElementHeightInv</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>La inversa del alto de la grilla en píxeles. </p>
<p>Obtenido del <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html" title="Frame representa un cuadro, una imagen, con los puntos singulares detectados. ">Frame</a> asociado. </p>

</div>
</div>
<a id="a7ad664a3275b80e901f3fa290ad7804e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float ORB_SLAM2::KeyFrame::mfGridElementWidthInv</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>La inversa del ancho de la grilla en píxeles. </p>
<p>Obtenido del <a class="el" href="class_o_r_b___s_l_a_m2_1_1_frame.html" title="Frame representa un cuadro, una imagen, con los puntos singulares detectados. ">Frame</a> asociado. </p>

</div>
</div>
<a id="ae7ca053915d4aaba66c1fd5962182d14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float ORB_SLAM2::KeyFrame::mfLogScaleFactor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logaritmo del factor de escala. </p>

</div>
</div>
<a id="a18fbd1aa1da7c7cd68cb05d8e5b78a08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float ORB_SLAM2::KeyFrame::mfScaleFactor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factor de escala entre dos niveles consecutivos de la pirámide. </p>

</div>
</div>
<a id="aa01e44ecc9b907b3f85094d84de08cb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector &lt;std::vector&lt;size_t&gt; &gt; &gt; ORB_SLAM2::KeyFrame::mGrid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afcb8246d60511b756ba241de680e96ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cv::Mat ORB_SLAM2::KeyFrame::mK</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Matriz K de calibración de cámara. </p>

</div>
</div>
<a id="a40712f54ab899a6dbd795405a4984ab5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ORB_SLAM2::KeyFrame::mLoopScore</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable efímera usadas por la base de datos de keyframes. </p>

</div>
</div>
<a id="a30315bba6d290ec12227cf9c0aed5df1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex ORB_SLAM2::KeyFrame::mMutexConnections</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>mutex de acceso al grafo de conexiones. </p>
<p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a09cb8502509c136536bf8d45793f8872" title="Actualiza los mejores covisibles. ">KeyFrame::UpdateBestCovisibles</a> y <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a365ec4d06acbbcd668aa5a069c69fdaa" title="Intenta eliminar el keyframe y marcarlo como malo. ">KeyFrame::SetBadFlag</a> operan en bucle construyendo o remendando el grafo de conexiones.</p>
<p>Durante estas operaciones se deben prevenir modificaciones a variables del grafo. Este mutex está aplicado en todos los métodos que deben esperar la finalización de las operaciones mencionadas.</p>
<p>Agregado mío: Para prevenir que el keyframe se siga usando y registrando justo cuando se está marcando como malo con SetBadFlag, los siguientes métodos que utilizan este mutex y registran el keyframe en algún lugar, sólo procederán luego de verificar la marca <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a9ed66ca840fb2288ee6b700bb4fc6858" title="Flag de eliminación. ">KeyFrame::mbBad</a>. Los métodos con este agregado son:</p>
<ul>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a2394adfb627d9cf87ed8da78f6b0d709" title="Agrega un keyframe hijo al grafo de keyframes KeyFrame::mspChildrens. ">KeyFrame::AddChild</a>, evita que el keyframe vuelva al grafo de covisibilidad</li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a8d21a23485b7c104a73d6ad3cccf4e93" title="Conecta el keyframe con otro en el grafo de covisibilidad. ">KeyFrame::AddConnection</a>, evita que el keyframe vuelva al grafo de conexiones</li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#afe7026956c91d4e0a01812be9dc7e8d5" title="Releva la covisibilidad y crea las conexiones en el grafo de covisibilidad. ">KeyFrame::UpdateConnections</a>, evita volver a cargar mConnectedKeyFrameWeights, mvpOrderedConnectedKeyFrames y mvOrderedWeights</li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a09cb8502509c136536bf8d45793f8872" title="Actualiza los mejores covisibles. ">KeyFrame::UpdateBestCovisibles</a> nunca se invocará si se acaba de ejecutar SetBadFlag</li>
</ul>
<p>No se incluyen los invocados por <a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html" title="Cierre de bucles. ">LoopClosing</a>, pues éstos tienen la potestad de exigir que el <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a> no se elimine. </p>

</div>
</div>
<a id="acb19a0cf32ad590df9794f77585e9ce8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex ORB_SLAM2::KeyFrame::mMutexFeatures</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>mutex de acceso a mvpMapPoints. </p>
<p>Controla el acceso de escritura al vector mvpMapPoints. Previene que se lo modifique mientras se lo copia con <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aabc5f6491c32999d9f546669737547bf" title="Devuelve una copia del vector de puntos 3D. ">KeyFrame::GetMapPointMatches</a>.</p>
<p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a365ec4d06acbbcd668aa5a069c69fdaa" title="Intenta eliminar el keyframe y marcarlo como malo. ">KeyFrame::SetBadFlag</a> usa este mutex. </p>

</div>
</div>
<a id="a7ca0141e2657237c4b7847512585cb49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex ORB_SLAM2::KeyFrame::mMutexPose</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>mutex de acceso a la pose Tcw. </p>
<p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aa799150fa33f3b9a404226454b96c95a" title="Establece Tcw, la pose del keyframe. ">KeyFrame::SetPose</a> realiza varias operaciones matriciales.</p>
<p>Este mutex se incluye en los métodos que clonan matrices de pose. Las matrices de pose no se deben acceder durante esta operación, pues la clonación como las operaciones matriciales no son monolíticas. </p>

</div>
</div>
<a id="a484457e131f76713de4dc4e0bc9b5fed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long unsigned int ORB_SLAM2::KeyFrame::mnBAFixedForKF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable efímera usadas por el mapeo local. </p>

</div>
</div>
<a id="a31b686c81674d0248b5f7dabdfd58ecb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long unsigned int ORB_SLAM2::KeyFrame::mnBAGlobalForKF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable efímera usadas por cierre de bucle. </p>

</div>
</div>
<a id="a75767b3e2e5f8eb4b4b73cba161b097b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long unsigned int ORB_SLAM2::KeyFrame::mnBALocalForKF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable efímera usadas por el mapeo local. </p>

</div>
</div>
<a id="a75ad29c06d8c969a341d9f633b43569e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const long unsigned int ORB_SLAM2::KeyFrame::mnFrameId</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Id del frame asociado. </p>
<p>El id es un número de secuencia de los frames. </p>

</div>
</div>
<a id="a2bad332e7057e8f59d630e78c7994129"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long unsigned int ORB_SLAM2::KeyFrame::mnFuseTargetForKF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable efímera usadas por <a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html" title="Objeto único que se ejecuta en su propio Trhead, y se inicia con Run(). ">Tracking</a>. </p>

</div>
</div>
<a id="a7fe0d03aabb1643abb8f4eef33fdf95a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ORB_SLAM2::KeyFrame::mnGridCols</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dimensiones de la grilla del frame para acelerar macheo. </p>
<p>Están dadas por mnGridCols y mnGridRows. </p>

</div>
</div>
<a id="afb859eb91a2365180b006a185aa36ba6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ORB_SLAM2::KeyFrame::mnGridRows</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dimensiones de la grilla del frame para acelerar macheo. </p>
<p>Están dadas por mnGridCols y mnGridRows. </p>

</div>
</div>
<a id="a1e3d56caca4e4cc372c36a3270d490c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long unsigned int ORB_SLAM2::KeyFrame::mnId</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Id del keyFrame. </p>
<p>El id es un número de secuencia. </p>

</div>
</div>
<a id="ae3446f5fd861f1e51faf9191c1eb75ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long unsigned int ORB_SLAM2::KeyFrame::mnLoopQuery</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable efímera usadas por la base de datos de keyframes. </p>

</div>
</div>
<a id="a36d7ead1b29c188be610208f11625d24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::KeyFrame::mnLoopWords</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable efímera usadas por la base de datos de keyframes. </p>

</div>
</div>
<a id="a677fd210bec35232bda003b543d0acfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ORB_SLAM2::KeyFrame::mnMaxX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vértices de la imagen antidistorsionada: mnMinX, mnMinY, mnMaxX, mnMaxY. </p>

</div>
</div>
<a id="ababbbd404314965b13a51e6414dce6ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ORB_SLAM2::KeyFrame::mnMaxY</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vértices de la imagen antidistorsionada: mnMinX, mnMinY, mnMaxX, mnMaxY. </p>

</div>
</div>
<a id="a02b00239e47ff44e5578c2eeaf3d3cc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ORB_SLAM2::KeyFrame::mnMinX</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vértices de la imagen antidistorsionada: mnMinX, mnMinY, mnMaxX, mnMaxY. </p>

</div>
</div>
<a id="ab96accf480c4bbc3212efb47278db8c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ORB_SLAM2::KeyFrame::mnMinY</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vértices de la imagen antidistorsionada: mnMinX, mnMinY, mnMaxX, mnMaxY. </p>

</div>
</div>
<a id="a028c2a2f0f737ec09719712c84339748"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long unsigned int ORB_SLAM2::KeyFrame::mnRelocQuery</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable efímera usadas por por la base de datos de keyframes. </p>

</div>
</div>
<a id="a0b1f8023efe8ddf58ac5d1d2cf41c0cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ORB_SLAM2::KeyFrame::mnRelocWords</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable efímera usadas por la base de datos de keyframes. </p>

</div>
</div>
<a id="abd3b2544330774672483656955e0ca03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ORB_SLAM2::KeyFrame::mnScaleLevels</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pose de cámara relativa a su padre. </p>
<p>Se computa cuando el keyframe se marca como malo, y no lo usa nadie.</p>
<p>En OS1 se desactivó.Cantidad de niveles de la pirámide. </p>

</div>
</div>
<a id="a1c775159303dc3435fc05e73f30f2865"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long unsigned int ORB_SLAM2::KeyFrame::mnTrackReferenceForFrame</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable efímera usadas por <a class="el" href="class_o_r_b___s_l_a_m2_1_1_tracking.html" title="Objeto único que se ejecuta en su propio Trhead, y se inicia con Run(). ">Tracking</a>. </p>

</div>
</div>
<a id="a0d0f82c40703deb82fbc593d9e17ea1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame_database.html">KeyFrameDatabase</a>* ORB_SLAM2::KeyFrame::mpKeyFrameDB</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Base de datos de keyframes, donde se encuentra este keyframe. </p>
<p>Se recibe como argumento del constructor. Se utiliza exclusivamente en SetBadFlag, para quitar el propio keyFrame de la base de datos. Esa base de datos se consulta con un descriptor BoW para conseguir la lista de keyframes que lo contienen. </p>

</div>
</div>
<a id="ab1fd59a0e3f3c32cf90c03a087ffd31b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_map.html">Map</a>* ORB_SLAM2::KeyFrame::mpMap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mapa donde se encuentra el keyFrame. </p>
<p>Se recibe como argumento del constructor. Se utiliza exclusivamente en SetBadFlag, para quitar el propio keyFrame del mapa. </p>

</div>
</div>
<a id="ab268c7bd221fb11554a9f21f56a5550a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_o_r_b___s_l_a_m2.html#a2fafba714858cab1bb18d438e2e83c5d">ORBVocabulary</a>* ORB_SLAM2::KeyFrame::mpORBvocabulary</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vocabulario BoW para ORB. </p>
<p>Representa un diccionario de clasificación que devuelve un BoW a partir de un descriptor ORB. </p>

</div>
</div>
<a id="a94bbb0261caf3f1ed0c434c9fca1e886"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a>* ORB_SLAM2::KeyFrame::mpParent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a> padre en el grafo. </p>
<p>Los keyframes se construyen con mpParent = NULL, <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#afe7026956c91d4e0a01812be9dc7e8d5" title="Releva la covisibilidad y crea las conexiones en el grafo de covisibilidad. ">KeyFrame::UpdateConnections</a> adopta la primer conexión como padre. El primer keyframe no tiene padre. </p>

</div>
</div>
<a id="a78f768a3601ac95f99dff3fd511f2a6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ORB_SLAM2::KeyFrame::mRelocScore</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable efímera usadas por la base de datos de keyframes. </p>

</div>
</div>
<a id="ac647a33b4a6d158b640c5482ed57bbfe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a>*&gt; ORB_SLAM2::KeyFrame::mspChildrens</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>KeyFrames hijos en el grafo, que conforman el spanning tree del grado esencial. </p>
<p>Se va poblando a medida que otros keyframes identifican a éste como padre.</p>
<p>La identificación ocurre en el primer llamado a UpdateConnections apenas se crea el keyframe, que recorre los keyframes con puntos covisibles, y elige como padre al que comparte más puntos.</p>
<p>Esto implica que es posible reconstruir este set ejecutando UpdateConnections en cada <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html" title="Cuadro clave, keyframe. ">KeyFrame</a>.</p>
<p>mspChildrens se usa con los siguientes métodos:</p><ul>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a2394adfb627d9cf87ed8da78f6b0d709" title="Agrega un keyframe hijo al grafo de keyframes KeyFrame::mspChildrens. ">KeyFrame::AddChild</a></li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aefdd69627fd6a204a6ef4539303b81f6" title="Borra un keyframe hijo del grafo KeyFrame::mspChildrens. ">KeyFrame::EraseChild</a></li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a618ddd51eab47bf1d84a21d2e818a787" title="Devuelve los hijos de este keyframe. ">KeyFrame::GetChilds</a></li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a2276fdbae634194e790878adebba7861" title="Indica si un keyframe es hijo de éste. ">KeyFrame::hasChild</a></li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a365ec4d06acbbcd668aa5a069c69fdaa" title="Intenta eliminar el keyframe y marcarlo como malo. ">KeyFrame::SetBadFlag</a></li>
</ul>
<p>El grafo esencial dispone de estos otros métodos para su administración:</p><ul>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a660cfc9a6ccf87e5497356d0d98ef06f" title="Informa el keyframe padre. ">KeyFrame::GetParent</a></li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a3232df2495062749da1344db3e5a487f" title="Cambia el padre del keyframe en el grafo. ">KeyFrame::ChangeParent</a></li>
<li><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#afe7026956c91d4e0a01812be9dc7e8d5" title="Releva la covisibilidad y crea las conexiones en el grafo de covisibilidad. ">KeyFrame::UpdateConnections</a> </li>
</ul>

</div>
</div>
<a id="a64c0b63cb66f5ca99639c6c54aa67e1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a>*&gt; ORB_SLAM2::KeyFrame::mspLoopEdges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>KeyFrames que participan de un extremo de un bucle. </p>
<p><a class="el" href="class_o_r_b___s_l_a_m2_1_1_loop_closing.html#aa007e0678582ec0de5d71280d23af540" title="Corrige el bucle con los encastres elaborados por LoopClosing::ComputeSim3. ">LoopClosing::CorrectLoop</a> es el único método que agrega estos ejes, y que los consume indirectamente invocando <a class="el" href="class_o_r_b___s_l_a_m2_1_1_optimizer.html#a5a53ab409feed7f92547eb79a2d7f6e9" title="Optimiza el grafo esencial para cerrar un bucle. ">Optimizer::OptimizeEssentialGraph</a>.</p>
<p>No es efímero.</p>
<p>Todos los keyframes de este set están marcados para no borrar con <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aa64c7adb5f80f260cb7e997f68881b09" title="Previene la eliminación del keyframe mientras se utiliza en una detección de bucle. ">KeyFrame::SetNotErase</a>. Esto significa que no pueden ser malos. </p>

</div>
</div>
<a id="a4a6fb84afa3701dcc6b1e3e76ccb36fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ORB_SLAM2::KeyFrame::mTcwBefGBA</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable usada en cierre de bucle. </p>

</div>
</div>
<a id="ac9bdd885bb078b5e1910c2317e9aa112"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ORB_SLAM2::KeyFrame::mTcwGBA</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable usada en cierre de bucle. </p>

</div>
</div>
<a id="ab4fa3d61a524547cfe2be2523d199833"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double ORB_SLAM2::KeyFrame::mTimeStamp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time stamp. </p>

</div>
</div>
<a id="a320d543b9585072c264b4e6f7e334bad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;float&gt; ORB_SLAM2::KeyFrame::mvInvLevelSigma2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inversa de sigma cuadrado para cada nivel de la pirámide. </p>

</div>
</div>
<a id="aa1bcd5810e62ec163a3f38ccb806d04a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;cv::KeyPoint&gt; ORB_SLAM2::KeyFrame::mvKeys</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puntos singulares visualizados por el keyframe. </p>

</div>
</div>
<a id="aaf6c65fc098f41ff418a65934f514ce3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;cv::KeyPoint&gt; ORB_SLAM2::KeyFrame::mvKeysUn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puntos singulares con coordenadas "antidistorsionadas". </p>
<p>Los elementos se corresponden con los de mvKeys. </p>

</div>
</div>
<a id="aa4a9029bf7ea62953ac38644756fcd3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;float&gt; ORB_SLAM2::KeyFrame::mvLevelSigma2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sigma cuadrado (cuadrado de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a8cdc02a7bccd3b75e61351a1f14f9c04" title="Factores de escala absolutos para cada nivel de la pirámide. ">KeyFrame::mvScaleFactors</a>) para cada nivel de la pirámide. </p>

</div>
</div>
<a id="aeac0492454556dc98bb6bd895acfec9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; ORB_SLAM2::KeyFrame::mvOrderedWeights</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pesos de los keyframes de <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#af4a83f5b32cf53c0ad87702226b9dff8" title="Keyframes covisibles ordenados por peso, actualizado vía KeyFrame::UpdateBestCovisibles. ">KeyFrame::mvpOrderedConnectedKeyFrames</a>. </p>

</div>
</div>
<a id="a777aab9cb7c1fd8e83f143e77a9f1b03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_o_r_b___s_l_a_m2_1_1_map_point.html">MapPoint</a>*&gt; ORB_SLAM2::KeyFrame::mvpMapPoints</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Puntos del mapa asociado a los puntos singulares. </p>

</div>
</div>
<a id="af4a83f5b32cf53c0ad87702226b9dff8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a>*&gt; ORB_SLAM2::KeyFrame::mvpOrderedConnectedKeyFrames</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keyframes covisibles ordenados por peso, actualizado vía <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#a09cb8502509c136536bf8d45793f8872" title="Actualiza los mejores covisibles. ">KeyFrame::UpdateBestCovisibles</a>. </p>
<p>Este vector está alineado con <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#aeac0492454556dc98bb6bd895acfec9b" title="Pesos de los keyframes de KeyFrame::mvpOrderedConnectedKeyFrames. ">KeyFrame::mvOrderedWeights</a>, con los respectivos pesos de cada conexión. </p>

</div>
</div>
<a id="a8cdc02a7bccd3b75e61351a1f14f9c04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;float&gt; ORB_SLAM2::KeyFrame::mvScaleFactors</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factores de escala absolutos para cada nivel de la pirámide. </p>

</div>
</div>
<a id="ac9b6948404d0ade2779335708cd443b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ORB_SLAM2::KeyFrame::N</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cantidad de puntos singulares. </p>
<p>Tamaño de los vectores alineados KeyFrame::mKeys, KeyFrame::mKeysUn y <a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html#ae08ac0ce59e2c003c182f946de3b3bc0" title="Descriptores. ">KeyFrame::mDescriptors</a>. </p>

</div>
</div>
<a id="acb0d220936541a8afc020a65aa675559"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long unsigned int ORB_SLAM2::KeyFrame::nNextId =0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contador para autonumeración de ids. </p>

</div>
</div>
<a id="a3044f098f2b7d25b33b180b20c5a5fa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ORB_SLAM2::KeyFrame::Ow</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Centro de la cámara, posición de la cámara. </p>
<p>Se obtiene con GetCameraCenter. Vector de 3x1. </p>

</div>
</div>
<a id="a8dc31ef9a08d34ecb196f3e58a2c09b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ORB_SLAM2::KeyFrame::Tcw</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matriz de 4x4 de rototraslación en coordenadas homogéneas, que expresa la pose del keyframe. </p>
<p>SetPose determina su valor, y GetPose lo lee. GetRotation y GetTraslation obtienen la matriz de rotación y el vector traslación en coordenadas euclideanas.</p>
<p>Tcw es la transformación de coordenadas del mundo (w) a coordenadas de la cámara (c). Su inversa es Twc. </p>

</div>
</div>
<a id="a769de03e37e9531ab43625250287ff8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cv::Mat ORB_SLAM2::KeyFrame::Twc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matriz de 4x4 de rototraslación en coordenadas homogéneas, con la transformación inversa de Tcw. </p>
<p>Convierte un punto del sistema de referencia de la cámara al mundo. GetPoseInverse lee su valor. </p>

</div>
</div>
<a id="a71410c456b6354264ce0369883d96459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;cv::Vec3b&gt; ORB_SLAM2::KeyFrame::vRgb</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Color de los keypoints. </p>
<p>Para visualización solamente. Vector cargado en el constructor de keyframe, alineado con mvKeys </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/alejandro/Desarrollo eclipse/os1/include/<a class="el" href="_key_frame_8h_source.html">KeyFrame.h</a></li>
<li>/home/alejandro/Desarrollo eclipse/os1/src/<a class="el" href="_key_frame_8cc.html">KeyFrame.cc</a></li>
<li>/home/alejandro/Desarrollo eclipse/os1/src/<a class="el" href="_serializer_8cpp.html">Serializer.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_o_r_b___s_l_a_m2.html">ORB_SLAM2</a></li><li class="navelem"><a class="el" href="class_o_r_b___s_l_a_m2_1_1_key_frame.html">KeyFrame</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
